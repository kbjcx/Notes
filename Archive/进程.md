---
aliases: [Process]
area: 操作系统
project: 
date: 2023-04-13 22:06
---
---
#### Description
**进程的基本状态**
- 运行状态 (*Running*): 该时刻进程占用 CPU
- 就绪状态 (*Ready*): 进程可运行, 但是由于其他进程处于运行状态而暂时停止运行
- 阻塞状态 (*Blocked*): 该进程暂时停止运行, 等待某一事件的发生, 这个时候就算给它 CPU 控制权, 它也无法运行
- 创建状态 (*New*): 进程正在被创建时的状态
- 结束状态 (*Exit*): 进程正在从系统中消失的状态

**进程状态之间的变迁如下**
![[Pasted image 20230414113552.png]]

对于「阻塞状态」而言, 我们不希望大量处于阻塞状态的进程占据着物理内存空间, 因为这是一种浪费物理内存的行为. 因此操作系统通常**<font color="#0593A2">将处于阻塞状态的进程的物理空间换出到硬盘, 等需要再次运行时再从硬盘换入到内存</font>**. 
描述进程没有占用实际物理内存空间的情况, 这个状态就是**<font color="#0593A2">挂起状态</font>**
**挂起状态分为两种**
- 阻塞挂起状态: 进程在外存冰等待某个时间的出现
- 就绪挂起状态: 进程在外存, 但是只要进入内存就能立即运行

**导致进程挂起的原因**
1. 进程所使用的内存空间不在物理内存上
2. 通过 sleep 让进程间歇性挂起, 就是设置一个定时器, 到期后唤醒进程
3. 用户希望挂起一个程序的执行, 比如在 Linux 中用 `CTRL+Z` 挂起进程

**进程的控制结构**
在操作系统中, 用进程控制块 (*Process Control Block*, PCB) 数据结构来描述进程
> [!important] 
> PCB 是进程存在的唯一标志, 一个进程存在必然会有一个 PCB, 如果进程消失了, 那么 PCB 也会随之消失

**PCB 包含信息**
- 进程描述信息: 
    - 进程描述符: 标识各个进程, 每个进程都有一个且唯一的标识符
    - 用户标识符: 进程归属的用户, 用户标识符主要为共享和保护服务
- 进程控制和管理信息: 
    - 进程当前状态, 如*New*, *Ready*, *Running*, *Waiting*, *Blocked*等
    - 进程优先级: 进程抢占 CPU 时的优先级
- 资源分配清单: 
    - 有关内存地址空间或虚拟地址空间的信息, 所打开文件的列表和所使用的 IO 设备信息
- CPU 相关信息: 
    - CPU 中各个寄存器的值, 当进程被切换时, CPU 的状态信息都会被保存在相应的 PCB 中, 以便进程重新执行时, 能从断点处继续执行

**进程的控制**
1. 创建进程 (*New*)
    操作系统允许一个进程创建另一个进程, 并且允许子进程继承父进程的所有资源
    创建进程的过程如下: 
    - 申请一个空白的 PCB, 并向 PCB 中填写一些控制和管理进程的信息
    - 为该进程分配运行时所必须的资源, 比如内存资源
    - 将该 PCB 插入到就绪链表中, 等待被调度运行
2. 终止进程 (*Exit*)
    进程结束有三种方式: 正常结束, 异常结束以及外界干预 (`kill`)
    当子进程被终止时, 其在父进程处继承的资源应当还给父进程; 当父进程被终止时, 该父进程的子进程就会变为孤儿进程, 会被 1 号进程接收, 并由 1 号进程对其完成状态收集工作.
    终止进程的过程如下: 
    - 查找需要终止的进程的 PCB
    -  如果处于执行状态, 则立即终止该进程的执行, 并将 CPU 资源分配给其他进程
    - 将该进程拥有的全部资源归还给操作系统
    - 如果其还有子进程,  则将该进程的子进程交给 1 号进程进行管理
    - 将其从 PCB 所在链表中删除
3. 阻塞进程 (*Blocked*)
    当进程需要等待某事完成时, 可以调用阻塞语句把自己阻塞等待, 但是一旦阻塞只能由其他线程唤醒
    阻塞进程的过程如下:
    - 找到将要被阻塞的进程对应的 PCB
    - 如果该进程为运行状态, 则保护其现场, 将其状态转换为阻塞状态, 停止运行
    - 将该 PCB 插入到阻塞链表中去
4. 唤醒进程
   只有当阻塞进程期待的事件发生时, 才由发现者进程用唤醒语句唤醒阻塞进程
   唤醒进程的过程如下: 
   - 在该事件的阻塞链表中找到相应进程的 PCB
   - 将其从阻塞链表中移除, 并将其转为就绪状态
   - 把该 PCB 插入就绪链表中, 等待调度程序调度

**进程上下文切换场景**
- 当进程分配的时间片运行完毕, 进程从运行态转变为就绪态, 系统从就绪链表中选择另一个进程运行
- 进程在系统资源不足的情况下, 要等到系统资源足够了才能运行, 

---
#### Source
- [5.1 进程、线程基础知识 | 小林coding](https://xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6)
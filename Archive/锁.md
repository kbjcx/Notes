---
aliases: []
area: 操作系统
project: 
date: 2023-09-04 16:43
tags: []
---
---
# 忙等待锁 [自旋锁（spin lock）]
## 测试和置位
测试和置位是 CPU 体系提供的**原子操作指令**——（Test-and-Set）

如果用 C 代码表示 Test-and-Set 指令，形式如下：
```c
int TestAndSet(int* old_ptr, int new) {
    int old = *old_ptr;
    *old_ptr = new;
    return old;
}
```
测试并设置指令主要完成两项工作：
1. 把 `old_ptr` 更新为 `new` 的新值
2. 返回 `old_ptr` 的旧值
> [!important] 
> 这些代码是**原子执行**，原子操作就是要么全部执行，要么都不执行，不能出现执行到一半的中间状态

可以基于 Test-and-Set 指令来实现「忙等待锁」：
```c
typedef struct loct_t {
    int flag;
} lock_t;

void init(lock_t* lock) {
    lock->flag = 0;
}

void lock(lock_t* lock) {
    while (TestAndSet(&lock->flag, 1) == 1);
}

void unlock(lock_t* lock) {
    lock->flag = 0;
}
```
- 第一个场景是，首先假设一个线程在运行，调用 `lock ()`，没有其他线程持有锁，所以 `flag` 是 0。当调用 `TestAndSet (flag, 1) `方法，返回 0，线程会跳出 `while` 循环，获取锁。同时也会原子的设置 `flag` 为 1，标志锁已经被持有。当线程离开临界区，调用 `unlock ()` 将 `flag` 清理为 0。
- 第二种场景是，当某一个线程已经持有锁（即 `flag` 为 1）。本线程调用 `lock ()`，然后调用 `TestAndSet (flag, 1)`，这一次返回 1。只要另一个线程一直持有锁，`TestAndSet ()` 会重复返回 1，本线程会一直忙等。当 `flag` 终于被改为 0，本线程会调用 `TestAndSet ()`，返回 0 并且原子地设置为 1，从而获得锁，进入临界区

# 无等待锁 [互斥锁]
无等待锁顾明思议就是获取不到锁的时候，不用自旋

既然不想自旋，那当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行

> [!faq] 互斥锁与自旋锁的区别
> - 互斥锁加锁失败后，线程会释放 CPU，拿给其他线程；自旋锁加锁失败后，线程会忙等待，直到他拿到锁；==当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对==
> - 对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的；当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程。因此互斥锁加锁失败时会产生性能开销成本（两次线程上下文切换，只需要切换线程私有数据、寄存器、程序计数器等不共享的数据）
> - 如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁
> - 自旋锁是通过 CPU 提供的 CAS 函数（原子操作Compare And Swap），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换

> [!attention] 
> 需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU

# 读写锁
读写锁由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁，因此**读写锁适用于能明确区分读操作和写操作的场景**

根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」：
1. 「读优先锁」
    「读优先锁」期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁
2. 「写优先锁」
    「写优先锁」是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁

> [!warning] 
> 读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。
> 写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。
> 既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」
> **用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象**

# 悲观锁与乐观锁
==互斥锁、自旋锁、读写锁，都是属于悲观锁==

悲观锁认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁

乐观锁假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。**乐观锁全程并没有加锁，所以它也叫无锁编程**

==CAS 是乐观锁==









---

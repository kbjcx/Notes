---
aliases: []
area: 操作系统
project: 
date: 2023-09-04 16:43
tags: []
---
---
# 忙等待锁 [自旋锁（spin lock）]
## 测试和置位
测试和置位是 CPU 体系提供的**原子操作指令**——（Test-and-Set）

如果用 C 代码表示 Test-and-Set 指令，形式如下：
```c
int TestAndSet(int* old_ptr, int new) {
    int old = *old_ptr;
    *old_ptr = new;
    return old;
}
```
测试并设置指令主要完成两项工作：
1. 把 `old_ptr` 更新为 `new` 的新值
2. 返回 `old_ptr` 的旧值
> [!important] 
> 这些代码是**原子执行**，原子操作就是要么全部执行，要么都不执行，不能出现执行到一半的中间状态

可以基于 Test-and-Set 指令来实现「忙等待锁」：
```c
typedef struct loct_t {
    int flag;
} lock_t;

void init(lock_t* lock) {
    lock->flag = 0;
}

void lock(lock_t* lock) {
    while (TestAndSet(&lock->flag, 1) == 1);
}

void unlock(lock_t* lock) {
    lock->flag = 0;
}
```
- 第一个场景是，首先假设一个线程在运行，调用 `lock ()`，没有其他线程持有锁，所以 `flag` 是 0。当调用 `TestAndSet (flag, 1) `方法，返回 0，线程会跳出 `while` 循环，获取锁。同时也会原子的设置 `flag` 为 1，标志锁已经被持有。当线程离开临界区，调用 `unlock ()` 将 `flag` 清理为 0。
- 第二种场景是，当某一个线程已经持有锁（即 `flag` 为 1）。本线程调用 `lock ()`，然后调用 `TestAndSet (flag, 1)`，这一次返回 1。只要另一个线程一直持有锁，`TestAndSet ()` 会重复返回 1，本线程会一直忙等。当 `flag` 终于被改为 0，本线程会调用 `TestAndSet ()`，返回 0 并且原子地设置为 1，从而获得锁，进入临界区

# 无等待锁 [互斥锁]
无等待锁顾明思议就是获取不到锁的时候，不用自旋

既然不想自旋，那当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行

> 互斥锁与自旋锁的区别
> 互斥锁加锁失败后，线程会释放 CPU，拿给其他线程；自旋锁加锁失败后，线程会忙等待，直到他拿到锁
> 对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的；当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程。因此互斥锁加锁失败时会产生性能开销成本（两次线程上下文切换，只需要切换线程私有数据、寄存器、程序计数器等不共享的数据）

---

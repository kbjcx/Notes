---
aliases: []
area: 分布式
project: 
date: 2023-08-08 14:27
tags: []
---
---
#### Content
事务必须遵从四个属性 **ACID**：
- **原子性（Atomicity）：** 一个事务包含的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束，即使事务在执行过程中发生错误，也会被回滚 Rollback 到事务开始前的状态，就像这个事务从来没有执行过一样，即事务中的操作不可分割
- **一致性（Consistency）：** 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。事务必须保证数据库可以从一个一致的状态转移到另一个一致的状态，这种一致性要求不仅指常见的数据库完整性约束（例如主键、外键、触发器、 check 等约束），有时还需要由用户（应用程序）来保证，例如用户指定数据库字段必须满足 $A+B=100$，如何保证该约束是用户层编写事务的程序员的职责
- **隔离性（Isolation）：** 数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止在多个事务并发执行时，由于交叉执行而导致数据出现异常的情况。不同的隔离级别有着不同的保证
- **持久性（Durability）：** 事务结束后，对数据的修改就是永久的，即便系统出现故障也不会丢失数据。在实际项目中，这意味着数据库会将数据写入非易失性存储设备，如磁盘或 SSD

> [!attention] 
> ACID 中的一致性和 CAP 定理中的一致性是不一样的，ACID 中的 C 属于数据库事务；领域的概念，指在事务开始之前和事务结束以后，数据库的完整性没有被破坏；而 CAP 定理中的 C 指的是线性一致性

**分布式事务**一般是单机事务的两种变体：
1. **第一种变体：** 同一份数据需要在多个副本上更新，一个分布式事务需要更新所有的副本，不能有一个副本提交了，而另一个副本回滚了
2. **第二种变体：** 数据进行了分区，一个事务需要跨节点保证数据的一致性

#### 原子提交
分布式事务的原子性通过原子提交协议（Atomic Commit Protocol，ACP）来实现，原子提交协议（算法）必须满足以下三个特性：
1. **协定性（Agreement）** 所有进程都决议出一个值，相当于所有进程要么一起提交事务，要么一起终止事务，不存在一个提交事务一个终止事务的情况
2. **有效性（Validity）** 如果所有进程都决定提交事务并且没有任何故障发生，那么最终整个系统将提交事务；只要有一个进程终止事务，系统将终止事务
3. **终止性（Termination）** *弱终止条件：* 所有如果没有任何故障发生，那么所有进程最终都会最初决议（提交或终止事务）；*强终止条件：* 也称为*非阻塞条件*，指没有发生故障的进程最终会做出决议

##### 两阶段提交
**两阶段提交的基本思想**是既然仅仅发送一个请求不足以知道其他节点能否成功提交事务，最直接的想法就是再增加一轮请求，先检查每个节点上的状态是否能够满足事务正确性，在进行事务操作

两阶段提交包含两个角色：**协调者** 和 **参与者**，协调者负责协调算法的各个阶段，而参与者则参与到事务中执行事务操作，可以选择其中一个参与者来同时扮演协调者

***两阶段提交的过程：***
**一阶段被称为准备阶段或是投票阶段**
1. 协调者向参与者并行发送消息，询问参与者是否可以提交事务，并等待参与者响应
2. 参与者检查执行事务所需条件和资源（如权限验证、上锁等），准备好后参与者执行事务操作，并记录操作日志
3. 参与者响应协调者发起的请求，如果参与者发现事务的所有操作都成功，则返回是；如果参与者发现所需条件和资源检查失败，或者事务操作执行失败，则返回否
**第二阶段称为提交阶段**
如果所有的参与者都回复是，那么：
1. 协调者向所有参与者发送提交消息，指示参与者提交本次事务，等待参与者响应
2. 参与者收到提交消息后，正式提交事务，完成事务提交操作后，清理占用资源，例如释放锁等，并记录操作日志
3. 参与者终止事务后响应协调者，协调者收到所有参与者消息后，确认实事务完成
只要有一个参与者恢复了否，那么：
1. 协调者向所有参与者发送终止消息，指示参与者终止本次事务，等待参与者响应
2. 参与者收到终止消息后，利用其第一阶段的日志回滚所执行的事务操作，并清理占用资源
3. 终止后参与者响应协调者，协调者收到所有参与者消息后，确认事务终止

> [!faq] 两阶段提交可能发生的故障
> 1. 第一种情况是，如果在第一阶段，参与者在恢复协调者之前发生了故障，那么从协调者的角度来看，有一个参与者还没有确认，所以无法决定事务如何进行，只能一直等待参与者回复，如果参与者已知无法恢复正常工作，则协调者会无限等待下去
>     *协调者可以设置一个超时等待时间，如果参与者在超时时间内没有回复，那么协调者就认为这个参与者投了反对票*
> 1. 第二种情况是，如果在第一阶段，协调者在向参与者发送准备请求后立即发生故障，那么参与者将阻塞，一直等到协调者恢复正常后才能知道本次事务是要提交还是要中止。可见，**协调者存在单点故障问题**，再加上协议的阻塞性，如果协调者在特定阶段宕机，那么参与者将阻塞下去。如果此时数据库还锁定了事务相关的数据和资源，后续的事务也无法访问这些数据，则可能导致整个系统停顿，有时可能需要人工干预来解决
>     *两阶段提交只满足弱终止条件，如果有节点发生故障，没有发生故障的节点无法决定事务走向，两阶段提交是一种阻塞提交算法*
> 1. 第三种情况，假设在第二阶段，协调者只发送了一部分提交消息，此时发生了网络分区，导致剩下的那部分参与者没有收到提交消息，也就是说，只有部分参与者提交了事务，如果恰好此时别的事务能够读取到中间结果，那么会发现整个**系统出现数据不一致**的情况
> 1. 最极端的情况，如果在第二阶段，协调者只将消息发送给一个参与者就立即宕机了，而收到这条消息的参与者也宕机了，那么此时即便选举出新的协调者，新协调者也无法知道此轮事务是要提交还是要中止，只有协调者和收到这条消息的参与者知道（但它们失效了）。此时新协调者不能直接中止事务，如果在失效的参与者上提交了事务，但在其他参与者上中止了，那么一旦参与者恢复，整个系统的数据将会彻底不一致；协调者也不能强制提交整个事务，因为最初的消息可能是中止消息，协调者并不打算提交这条事务，强制提交后参与者一旦恢复，整个系统的数据还是会不一致

综上所述，两阶段提交存在**同步阻塞问题**、**单点故障问题**、**数据不一致问题**及**提交阶段不确定问题**

##### 三阶段提交
三阶段提交在两阶段提交的第一阶段和第二阶段之间插入了一个预提交阶段，在预提交阶段协调者将第一阶段的投票结果发送给所有参与者，这样，如果在提交阶段协调者和收到消息的参与者发生了故障，则可以从剩下的参与者中选出一个来充当协调者，新的协调者可以根据预提交阶段的信息，判断是应该执行提交还是终止事务，继续安全的推进事务

***三阶段提交的过程：***
**第一阶段依然是准备阶段或是投票阶段，不过不执行事务操作**
1. 协调者向所有参与者并行发送准备消息，询问参与者是否准备好执行事务，并等待参与者响应
2. 参与者判断是否具备行事务的条件，具体如何判断不同的业务有着不同的计算方式。注意，如前所述，三阶段提交阶段只确认是否具备基本的执行条件，并不会实际执行事务操作
3. 参与者响应协调者发起的请求。如果参与者确认事务能够执行且提交，则返回一条是；如果参与者认为事务无法顺利完成，则返回一条否
**第二阶段称为预提交阶段，根据上一阶段的响应情况，可能有以下两种情况：**
如果协调者收到上一阶段的响应都是“是”，那么：
1. 协调者向所有参与者发送预提交信息，询问参与者是否可以执行并提交事务，并等待参与者响应
2. 参与者收到预提交消息后，检查执行事务的必要条件和资源，条件满足后执行事务的所有操作，并记录日志
3. 参与者响应协调者发起的请求。如果参与者发现事务的所有操作都执行成功，则返回是；如果参与者发现所需条件和资源检查失败，或者事务操作执行失败，则返回否
如果协调者收到的响应中有一条“否”，或者等待超时都没有响应，那么协调者会向所有参与者发送终止消息，等待所有参与者终止事务并回复后，直接终止这次事务
**第三阶段仍然是提交阶段**
如果预提交阶段的响应全都是“是”，那么：
1. 协调者向所有参与者发送提交消息，指示参与者提交本次事务，等待参与者响应
2. 参与者收到提交消息后，正式提交事务。完成事务的提交操作后，清理占用的资源，例如释放锁等，并记录操作日志
3. 完成后参与者响应协调者，协调者收到所有参与者的消息后，确认事务完成
如果预提交阶段的响应中只要有一个参与者回复了“否”，或者超时没有回复协调者，那么：
1. 协调者向所有参与者发送终止消息，指示参与者终止本次事务，等待参与者响应
2. 参与者收到终止消息后，利用其预提交阶段记录的日志回滚事务操作，并清理占用的资源
3. 参与者终止事务后响应协调者，协调者收到所有参与者的消息后，确认事务终止

> [!faq] 三阶段提交存在什么问题呢？
> 1. 三阶段提交协议很容易受到网络分区的影响，假设在预提交阶段发生网络分区，恰好将收到预提交消息的节点和没有收到预提交消息的节点一分为二，同时协调者发生了故障。这种情况下两个网络分区都会选举出一个新的协调者，收到预提交信息的节点会继续提交事务，而没有收到预提交消息的节点不会执行事务提交，甚至可能会在超时时间后终止事务，**导致系统的数据出现不一致**
> 2. 一次事务至少需要三轮消息往返才能完成，这增加了事务的完成时间，导致较长的延时

> [!tip] 
> 三阶段提交协议满足了强终止性，但是受网络分区影响并且通信代价较高，因此，两阶段提交仍然是实现事务原子性的第一选择

##### Paxos 提交
##### 基于 Quorum 的提交
##### Saga 事务
实现分布式事务的原子性的代价是比较高的，通常需要进行多轮消息才能决议出系统的行为，此外，事务中的操作往往会占用一些系统资源，如上锁等，事务的持续时间越长，对系统的整体吞吐量的影响越大

有一类事务称为长活事务（Long-Lived Transaction，LLT），这种事务通常用于处理大量数据的场景

Saga 事务的本质是由一连串的子事务 $(T_1,T_2,\cdots,T_n)$ 组成，可以与其他事物交错执行，然而，他依然要保证所有的事务要么全部成功，要么都不成功。每个子事务 $T_x$ 都有对应的补偿事务 $C_x$，补偿事务用于在回滚的时候执行，由于事务常常与业务相关，所以补偿事务有时需要业务方来实现

**Saga 事务的优点：**
既满足业务需求，又保持系统松耦合架构，可以借助 Saga 事务的方式由业务方实现分布式事务

**Saga 事务的缺点：**
无法保证隔离性拆分的事务中间会插入其他事务，可能改变之前执行的子事务的判断


#### 并发控制
并发控制可以分为以下三类：
1. **悲观并发控制** 这种方法通常涉及锁，事务在使用任何数据之前，悲观地认为会有事务争抢，于是需要先获取数据的锁。如果一个事务持有了数据的锁，那么另一个事务必须等待前一个事务结束并释放锁，才能获取锁并使用数据。在悲观并发控制中，如果有锁争抢，比如多个事务同时访问同一个数据，就会造成事务等待。所以这里其实是*为了正确性而牺牲了性能*，该方法主要用来实现串行化的隔离级别
2. **乐观并发控制** 这种方法乐观的认为并发事务（尤其是并发写事务）是小概率事件，于是在事务结束后再检查事务的正确性。基本思想是，一个事务在执行时不考虑是否存在其他事务读写该事务正在操作的数据，只管继续执行读写操作。在事务提交的时候，再检查是不是有其他并发事务引起了冲突。如果没有冲突，那么这次事务就算完成了；如果最后检查发现事务操作的数据被其他并发事务修改并造成了冲突，那么必须中止当前事务，并在稍后重试事务
3. **多版本并发控制** 这种方法对每个数据项保存多个版本的数据，并保证每个事务的读操作读取到比该事务早的最后一次提交的数据。多版本并发控制主要用于实现快照隔离，快照隔离能避免绝大多数异常情况，又能拥有比串行化更好的并发性能。所以，多版本并发控制有着非常广泛的应用，在常见的数据库管理系统（如 MySQL、PostgreSQL、Microsoft SQL Server、Oracle、HBase 和 etcd)中都有实现

##### 两阶段锁
两阶段锁是一种悲观并发控制，使用锁来防止并发事务对数据的干扰，以实现串行化的隔离级别

锁可以细分为如下两种类型：
1. **读锁**  读锁也被称为共享锁，读取记录时需要获得该锁。因为一个读锁不会阻止另一个事务的读取，所以可以同时获得多个读锁。但读锁会阻止另一个事务的写入，另一个事务必须等待读操作完成并且释放了读锁才能获取写锁并执行写操作
2. **写锁** 写锁也被称为排他锁，当要写入、更新或删除条记录时需要先获得写锁。写锁会阻止其他事务的读和写操作，因此，其他事务必须等待写操作完成并且释放写锁，才能尝试获得适当的锁进行操作

所谓两阶段锁，指的是获取锁和释放锁的过程将一个事务分为扩张阶段和收缩阶段。在扩张阶段，事务不断上锁，但不允许释放任何锁；在收缩阶段，事务陆续释放锁，但没有新的加锁动作

两阶段锁用于实现串行化的隔离性，出资之外还有两阶段锁的变种**严格两阶段锁**和**强严格两阶段锁**
**严格两阶段锁**除了要求满足两阶段锁，还要求事务必须在提交之后方可释放它持有的所有排他锁，这个严格的要求保证了事务未提交时所更新的一切数据在事务提交之前都被排他锁独占，防止被其他事务读取到这些中间结果
**强严格两阶段锁**也叫严密两阶段锁，要求事务只有在结束之后才能释放事务的所有锁，大多数数据库选择强严格两阶段锁来实现事务串行化

> [!tip] 两阶段锁的缺点
> 锁机制会引起死锁，导致两个事务相互等待

> [!faq] 避免两阶段锁产生死锁的方法
> 1. **死锁避免** 事先判断事务是否真的需要所有锁，尽量只获取必要的锁，并以一种有序的方式去加锁，或者使用行级锁来减小加锁的粒度，但是无法完全避免死锁，只适合数据量较少的情况
> 2. **死锁预防** 如果发现获取的资源被锁住则尝试终止占有资源的事务，只要有*等待-死亡*和*伤害-等待*两种方案
> 3. **死锁检测** 如果通过死锁避免和死锁预防都没有杜绝死锁产生，那么就需要在事务的运行过程中检测死锁，从中干扰并打破死锁，死锁由于有着某种互相锁住对方资源的关系，因此可以将其转换为一个有向等待图，如果发现图中有环，此时可以选择造成死锁的一个事务中止来打破死锁

##### 乐观并发控制
如前所述，两阶段锁限制了系统的并发性能，于是有人想到不用锁的实现，即乐观并发控制。乐观并发控制乐观地认为，*大部分时候，事务冲突的可能性较小，事务顺利完成的可能性比失败的可能性要大*。因此，*乐观并发控制将重点放在事务提交时冲突检查上*，而不是直接锁住数据不允许访问

乐观并发控制算法主要有两类，一类是基于检查的并发控制，另一类是基于时间戳的并发控制

**基于检查的并发控制** (Validation-Based Concurrency Control)为每个事务涉及的数据创建一个私有的副本，所有的更新操作都在私有副本上执行，再通过检查原来的数据是否有冲突来决定是否能够提交事务。具体流程包括以下 3 个阶段：
1. **读取阶段** 该阶段将事务涉及的数据复制一份副本，放到一个私有的工作空间中，之后执行读操作读取私有副本中的数据，写操作将被记录到私有空间的临时文件中，此时事务尚未提交，其他事务无法访问此私有空间中的任何数据
2. **校验阶段** 当事务准备提交时进入校验阶段，首先检查在此期间事务是否与其他事务产生冲突，如果没有产生冲突，则事务顺利提交；如果产生冲突，则终止事务
3. **写入阶段** 也称为提交阶段，如果校验阶段成功提交事务，那么该阶段将私有空间中的数据永久的写入到数据库

**基于时间戳的并发控制** 会为每个事务和数据项分配时间戳
当事务读写某个数据项时，系统会记录最近读取或写入该数据的事务的开始时间戳，即每项数据会记录两个时间戳：
1. **写时间戳** 代表数据最近一次被写入的时间戳
2. **读时间戳** 代表数据项最近一次被读取的时间戳

对于读操作，如果事务开始的时间戳在数据的写时间戳之前，那么意味着事务读到了未来的数据，则中止事务；如果开始的时间戳大于数据项的写时间戳，则说明事务的读操作读到事务开始之前的数据项，事务读取数据并更新数据项的读时间戳，同时保存一份数据项的副本，以此保证在事务结束之前读到的数据项不会变

对于写操作，如果事务开始的时间戳在数据项的读时间戳或写时间戳之前，意味着事务修改了未来某个事务写或读的数据项，则中止事务；否则，意味着事务正在修改过去的数据项，事务写入数据项后，系统更新数据项的写时间戳，同时保存一份数据项副本，保证在事务结束之前读取到的数据项是相同的

> [!tip] 基于时间戳的并发控制的优缺点
> **优点**
> 1.  事务之间不必互相等待，不会造成死锁
> 2. 在单个事务读写不多且事务之间涉及的数据基本没有交集的情况下，可以节省大量的额外成本，提高系统的并发性能
> **缺点**
> 1. 可能产生不可恢复的操作
> 2. 实现全局精准的时间戳是十分困难的

##### 多版本并发控制
相比于乐观并发控制，多版本并发控制是一种使用更为广泛的并发控制机制。多版本并发控制可以看作在乐观并发控制的基础上增加了多个版本，即为每个数据项存储多个版本，每个事务读到的都是某个版本的数据项，写操作不覆盖已有的数据，而是新建一个新的版本，直到事务提交后才变为可见。这样一来，正在执行写操作的事务就不会阻塞需要读取相同数据的事务，因此，多版本并发控制具有非常好的读性能，适合实现快照隔离的隔离级别

###### 多版本两阶段锁






---

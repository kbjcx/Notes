---
aliases: []
area: 分布式
project: 
date: 2023-08-08 14:27
tags: []
---
---
#### Content
事务必须遵从四个属性 **ACID**：
- **原子性（Atomicity）：** 一个事务包含的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束，即使事务在执行过程中发生错误，也会被回滚 Rollback 到事务开始前的状态，就像这个事务从来没有执行过一样，即事务中的操作不可分割
- **一致性（Consistency）：** 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。事务必须保证数据库可以从一个一致的状态转移到另一个一致的状态，这种一致性要求不仅指常见的数据库完整性约束（例如主键、外键、触发器、 check 等约束），有时还需要由用户（应用程序）来保证，例如用户指定数据库字段必须满足 $A+B=100$，如何保证该约束是用户层编写事务的程序员的职责
- **隔离性（Isolation）：** 数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止在多个事务并发执行时，由于交叉执行而导致数据出现异常的情况。不同的隔离级别有着不同的保证
- **持久性（Durability）：** 事务结束后，对数据的修改就是永久的，即便系统出现故障也不会丢失数据。在实际项目中，这意味着数据库会将数据写入非易失性存储设备，如磁盘或 SSD

> [!attention] 
> ACID 中的一致性和 CAP 定理中的一致性是不一样的，ACID 中的 C 属于数据库事务；领域的概念，指在事务开始之前和事务结束以后，数据库的完整性没有被破坏；而 CAP 定理中的 C 指的是线性一致性

**分布式事务**一般是单机事务的两种变体：
1. **第一种变体：** 同一份数据需要在多个副本上更新，一个分布式事务需要更新所有的副本，不能有一个副本提交了，而另一个副本回滚了
2. **第二种变体：** 数据进行了分区，一个事务需要跨节点保证数据的一致性

#### 原子提交
分布式事务的原子性通过原子提交协议（Atomic Commit Protocol，ACP）来实现，原子提交协议（算法）必须满足以下三个特性：
1. **协定性（Agreement）** 所有进程都决议出一个值，相当于所有进程要么一起提交事务，要么一起终止事务，不存在一个提交事务一个终止事务的情况
2. **有效性（Validity）** 如果所有进程都决定提交事务并且没有任何故障发生，那么最终整个系统将提交事务；只要有一个进程终止事务，系统将终止事务
3. **终止性（Termination）** *弱终止条件：* 所有如果没有任何故障发生，那么所有进程最终都会最初决议（提交或终止事务）；*强终止条件：* 也称为*非阻塞条件*，指没有发生故障的进程最终会做出决议

##### 两阶段提交
**两阶段提交的基本思想**是既然仅仅发送一个请求不足以知道其他节点能否成功提交事务，最直接的想法就是再增加一轮请求，先检查每个节点上的状态是否能够满足事务正确性，在进行事务操作

两阶段提交包含两个角色：**协调者** 和 **参与者**，协调者负责协调算法的各个阶段，而参与者则参与到事务中执行事务操作，可以选择其中一个参与者来同时扮演协调者

***两阶段提交的过程：***
**一阶段被称为准备阶段或是投票阶段**
1. 协调者向参与者并行发送消息，询问参与者是否可以提交事务，并等待参与者响应
2. 参与者检查执行事务所需条件和资源（如权限验证、上锁等），准备好后参与者执行事务操作，并记录操作日志
3. 参与者响应协调者发起的请求，如果参与者发现事务的所有操作都成功，则返回是；如果参与者发现所需条件和资源检查失败，或者事务操作执行失败，则返回否
**第二阶段称为提交阶段**
如果所有的参与者都回复是，那么：
1. 协调者向所有参与者发送提交消息，指示参与者提交本次事务，等待参与者响应
2. 参与者收到提交消息后，正式提交事务，完成事务提交操作后，清理占用资源，例如释放锁等，并记录操作日志
3. 参与者终止事务后响应协调者，协调者收到所有参与者消息后，确认实事务完成
只要有一个参与者恢复了否，那么：
1. 协调者向所有参与者发送终止消息，指示参与者终止本次事务，等待参与者响应
2. 参与者收到终止消息后，利用其第一阶段的日志回滚所执行的事务操作，并清理占用资源
3. 终止后参与者响应协调者，协调者收到所有参与者消息后，确认事务终止

> [!faq] 两阶段提交可能发生的故障
> 1. 第一种情况是，如果在第一阶段，参与者在恢复协调者之前发生了故障，那么从协调者的角度来看，有一个参与者还没有确认，所以无法决定事务如何进行，只能一直等待参与者回复，如果参与者已知无法恢复正常工作，则协调者会无限等待下去
>     *协调者可以设置一个超时等待时间，如果参与者在超时时间内没有回复，那么协调者就认为这个参与者投了反对票*
> 1. 第二种情况是，如果在第一阶段，协调者在向参与者发送准备请求后立即发生故障，那么参与者将阻塞，一直等到协调者恢复正常后才能知道本次事务是要提交还是要中止。可见，**协调者存在单点故障问题**，再加上协议的阻塞性，如果协调者在特定阶段宕机，那么参与者将阻塞下去。如果此时数据库还锁定了事务相关的数据和资源，后续的事务也无法访问这些数据，则可能导致整个系统停顿，有时可能需要人工干预来解决
>     *两阶段提交只满足弱终止条件，如果有节点发生故障，没有发生故障的节点无法决定事务走向，两阶段提交是一种阻塞提交算法*
> 1. 第三种情况，假设在第二阶段，协调者只发送了一部分提交消息，此时发生了网络分区，导致剩下的那部分参与者没有收到提交消息，也就是说，只有部分参与者提交了事务，如果恰好此时别的事务能够读取到中间结果，那么会发现整个**系统出现数据不一致**的情况
> 1. 最极端的情况，如果在第二阶段，协调者只将消息发送给一个参与者就立即宕机了，而收到这条消息的参与者也宕机了，那么此时即便选举出新的协调者，新协调者也无法知道此轮事务是要提交还是要中止，只有协调者和收到这条消息的参与者知道（但它们失效了）。此时新协调者不能直接中止事务，如果在失效的参与者上提交了事务，但在其他参与者上中止了，那么一旦参与者恢复，整个系统的数据将会彻底不一致；协调者也不能强制提交整个事务，因为最初的消息可能是中止消息，协调者并不打算提交这条事务，强制提交后参与者一旦恢复，整个系统的数据还是会不一致

综上所述，两阶段提交存在**同步阻塞问题**、**单点故障问题**、**数据不一致问题**及**提交阶段不确定问题**

##### 三阶段提交
三阶段提交在两阶段提交的第一阶段和第二阶段之间插入了一个预提交阶段，在预提交阶段协调者将第一阶段的投票结果发送给所有参与者，这样，如果在提交阶段协调者和收到消息的参与者发生了故障，则可以从剩下的参与者中选出一个来充当协调者，新的协调者可以根据预提交阶段的信息，判断是应该执行提交还是终止事务，继续安全的推进事务

***三阶段提交的过程：***
**第一阶段依然是准备阶段或是投票阶段，不过不执行事务操作**
1. 协调者向所有参与者并行发送准备消息，询问参与者是否准备好执行事务，并等待参与者响应
2. 参与者判断是否具备行事务的条件，具体如何判断不同的业务有着不同的计算方式。注意，如前所述，三阶段提交阶段只确认是否具备基本的执行条件，并不会实际执行事务操作
3. 参与者响应协调者发起的请求。如果参与者确认事务能够执行且提交，则返回一条是；如果参与者认为事务无法顺利完成，则返回一条否
**第二阶段称为预提交阶段，根据上一阶段的响应情况，可能有以下两种情况：**
如果协调者收到上一阶段的响应都是“是”，那么：
1. 协调者向所有参与者发送预提交信息，询问参与者是否可以执行并提交事务，并等待参与者响应
2. 参与者收到预提交消息后，检查执行事务的必要条件和资源，条件满足后执行事务的所有操作，并记录日志
3. 参与者响应协调者发起的请求。如果参与者发现事务的所有操作都执行成功，则返回是；如果参与者发现所需条件和资源检查失败，或者事务操作执行失败，则返回否
如果协调者收到的响应中有一条“否”，或者等待超时都没有响应，那么协调者会向所有参与者发送终止消息，等待所有参与者终止事务并回复后，直接终止这次事务
**第三阶段仍然是提交阶段**
如果预提交阶段的响应全都是“是”，那么：
1. 协调者向所有参与者发送提交消息，指示参与者提交本次事务，等待参与者响应
2. 参与者收到提交消息后，正式提交事务。完成事务的提交操作后，清理占用的资源，例如释放锁等，并记录操作日志
3. 完成后参与者响应协调者，协调者收到所有参与者的消息后，确认事务完成
如果预提交阶段的响应中只要有一个参与者回复了“否”，或者超时没有回复协调者，那么：
1. 协调者向所有参与者发送终止消息，指示参与者终止本次事务，等待参与者响应
2. 参与者收到终止消息后，利用其预提交阶段记录的日志回滚事务操作，并清理占用的资源
3. 参与者终止事务后响应协调者，协调者收到所有参与者的消息后，确认事务终止

> [!faq] 三阶段提交存在什么问题呢？
> 1. 三阶段提交协议很容易受到网络分区的影响，假设在预提交阶段发生网络分区，恰好将收到预提交消息的节点和没有收到预提交消息的节点一分为二，同时协调者发生了故障。这种情况下两个网络分区都会选举出一个新的协调者，收到预提交信息的节点会继续提交事务，而没有收到预提交消息的节点不会执行事务提交，甚至可能会在超时时间后终止事务，**导致系统的数据出现不一致**
> 2. 一次事务至少需要三轮消息往返才能完成，这增加了事务的完成时间，导致较长的延时

> [!tip] 
> 三阶段提交协议满足了强终止性，但是受网络分区影响并且通信代价较高，因此，两阶段提交仍然是实现事务原子性的第一选择

#### Paxos 提交
#### 基于 Quorum 的提交
#### Saga 事务
实现分布式事务的原子性的代价是比较高的，通常需要进行多轮消息才能决议出系统的行为，此外，事务中的操作往往会占用一些系统资源，如上锁等，事务的持续时间越长，对系统的整体吞吐量的影响越大

有一类事务称为长活事务（Long-Lived Transaction，LLT），这种事务通常用于处理大量数据的场景

Saga 事务的本质是由一连串的子事务组成，可以与其他事物交错执行，然而，他依然要保证所有的事务要么全部成功，要么都不成功






---

---
aliases: []
area: redis
project: 
date: 2023-07-21 22:27
tags: []
---
---
#### Content
##### String
> [!info] String 类型底层数据结构实现主要是 int 和 [[简单动态字符串|SDS]]

##### 内部编码
1. ***int***
    如果一个字符串对象保存的是整数值，并且这个整数值可以用 `long` 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 `ptr` 属性里面（将 `void*` 转换成 `long`），并将字符串对象的编码设置为 `int`
1. ***embstr***
    如果字符串对象保存的是一个字符串，并且这个字符申的长度小于等于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为 `embstr`， `embstr` 编码是专门用于保存==短字符串==的一种优化编码方式
1. ***raw***
    如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为 `raw`

> [!attention] embstr 编码和 raw 编码的边界在 redis 不同版本中是不一样的：
> - redis 2.+ 是 32 字节
> - redis 3.0-4.0 是 39 字节
> - redis 5.0 是 44 字节

> [!question] embstr 和 raw 编码之间有什么区别？
> embstr 会通过一次内存分配函数来分配一块连续的内存空间来保存 `redisObject` 和 `SDS`，而 raw 编码会通过调用两次内存分配函数来分别分配两块空间来保存 `redisObject` 和 `SDS`
> embstr 的优点：
> -  embstr 编码将创建字符串对象所需的内存分配次数从raw 编码的两次降低为一次
> - 释放 embstr 编码的字符串对象同样只需要调用一次内存释放函数
> - 因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能
> 
> embstr 的缺点：
> - 如果字符串的长度增加需要重新分配内存时，整个 `redisObject` 和 `SDS` 都需要重新分配空间，所以**embstr 编码的字符串对象实际上是只读的**，redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序。当我们对 embstr 编码的字符串对象执行任何修改命令（例如 `append`）时，程序会先将对象的编码从 embstr 转换成 raw，然后再执行修改命令

##### 应用场景


---

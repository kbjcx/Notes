---
aliases: [Paging]
area: 操作系统
project: 
tag: TODO
date: 2023-04-11 17:20
---
---
#### Description
对于[[内存分段]]类说, 会出现外部内存碎片以及内存交换空间大的问题, 要解决这个问题就需要在交换内存时尽可能减少交换的数据, 这就需要用<font color="#0593A2">内存分页</font>来实现.

分页是把整个虚拟和物理内存空间分割成一段段固定大小的内存空间, 将其称为页 (Page), 对于 Linux 而言, 页的大小为 `4KB`

与内存分段一样, 分页机制也需要将虚拟地址与物理内存地址一一对应, 那么对于 32 位系统而言, 一个 4G 大小的内存, 假设分页大小为 `4KB` , 则需要分成 $2^{20}$ 个页, 由于每个页表项需要 4 个字节来存储, 那么就需要 `4MB` 的空间来存储一个页表. 对于不同的进程, 每个进程都需要存储一个页表, 那么就会极大地浪费系统的内存, 于是采用<font color="#0593A2">多级页表</font>的方式来减少页表的内存占用.

- 多级页表
对于上述内存而言, 如果将内存页表分为两级, 将一级页表分为 `1024` 个页表, 然后每个一级页表下再分为 `1024` 个二级页表
![[Pasted image 20230411211734.png]]
但是如果按照原来的方式分页的话, 那么一级页表就会多占据一级页表的内存大小, 当然, 这是建立在把所有的物理内存地址全部映射到一个进程的页表中, 但是根据[[局部性原理]], 对于一个进程而言吗, 一个进程使用的空间远远达不到整个内存大小, 因此对于一个进程而言, <font color="#0593A2">如果一个一级页表还没有被使用到, 那么其下的二级页表就不会被创建</font>. 
假设一个进程只使用了 $10\%$ 一级页表, 那么整个页表所占的内存空间就只需要 $4KB (一级页表)+10\%\times 4MB (二级页表)=0.404MB$, 相比于 4MB 是一个巨大的节约.

- 为什么不分级页表就不能像这样节省内存呢?
    保存在内存中的页表的职责是将虚拟地址翻译成物理地址, 因此<font color="#0593A2">虚拟页表一定需要覆盖全部的虚拟地址空间</font>, 如果虚拟地址操作系统在页表中找不到对应的页表项, 那么操作系统就不能工作.
- 分页是怎么解决内存分段的「[[内存碎片|外部内存碎片]]和内存交换效率低」的问题?
    内存分页的内存空间都是提前划分的分页, 页与页之间的排列是紧密的, 所以不会有外部碎片, 但是由于内存分页存在最小单位, 当进程所需的内存不足一页时, 最小分配内存仍然是一页, 导致了[[内存碎片|内部内存碎片]]的产生. 
    
    在[[内存交换]]时, 分页机制交换的最小单位为一页, 因此每次交换时写入磁盘的内存大小只有少数的一个页或几个页, 极大地提高了内存交换的效率.
- 分页机制下虚拟地址和物理地址如何映射?
    在分页机制下, 虚拟地址分为两个部分, 包含<font color="#0593A2">页号 (包含多级页号)</font>和<font color="#0593A2">页内偏移</font>. 页号作为页表的索引, 页表包含物理内存的基地址, 这个基地址加上页内偏移就找到了对应的物理内存. 

- 页表缺点: 查找复杂, 效率低, 引入 TLB
---
#### Source
- [4.1 为什么要有虚拟内存？ | 小林coding](https://xiaolincoding.com/os/3_memory/vmem.html#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8)
---
aliases: [哈希表, hash]
area: redis
project: 
date: 2023-08-02 10:16
tags: []
---
---
#### Content
**哈希表结构设计**:
```cpp
typedef struct dictht {
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;  
    //哈希表大小掩码，用于计算索引值
    unsigned long sizemask;
    //该哈希表已有的节点数量
    unsigned long used;
} dictht;
```
可以看到，哈希表是一个数组（`dictEntry **table`），数组的每个元素是一个指向「哈希表节点（`dictEntry`）」的指针
![[Pasted image 20230802185727.png]]

哈希表节点的结构如下：
```cpp
typedef struct dictEntry {
    //键值对中的键
    void *key;
  
    //键值对中的值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    //指向下一个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```

> [!tip] 
> 键值对中的值使用联合体来存储，这么做的好处是可以节省内存空间，因为当「值」是整数或浮点数时，就可以将值的数据内嵌在 `dictEntry` 结构里，无需再用一个指针指向实际的值，从而节省了内存空间

#### 哈希冲突
Redis 采用了==「链式哈希」==的方法来解决哈希冲突

> [!faq] 链式哈希是怎么实现的？
> 实现的方式就是每个哈希表节点都有一个 `next` 指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用 `next` 指针构成一个单项链表，被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来，这样就解决了哈希冲突

> [!tip] 链式哈希局限性也很明显
> 随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O (n)

要想解决这一问题，就需要进行 rehash，也就是对哈希表的大小进行扩展

#### Rehash
在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了==两个哈希表（ht[2]）==
```cpp
typedef struct dict{
     //类型特定函数
     void *type;
     //私有数据
     void *privdata;
     //哈希表
     dictht ht[2];
     //rehash 索引 当rehash不在进行时 值为-1
     int trehashidx; 
} dict;
```

Rehash 操作过程分为三步：
1. 给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍
2. 将「哈希表 1 」的数据迁移到「哈希表 2」 中
3. 迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」设置为「哈希表 1」，然后在「哈希表 2」新创建一个空白的哈希表，为下次 rehash 做准备

> [!important] 这种Rehash 方式的缺点
> 如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求

#### 渐进式 Rehash
为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了渐进式 rehash，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移
渐进式 Rehash 步骤如下：
1. 给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍
2. 在 rehash 进行期间，新增数据会被直接添加到「哈希表 2」，并且每次哈希表元素进行**新增、删除、查找或者更新操作**时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上，`trehashidx` 为当前需要移动的键值对，每次增加 1
3. 随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作

> [!attention] 
> 在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行

**触发条件：**
rehash 的触发条件跟 **负载因子（load factor）** 有关系
$$
负载因子 = 哈希表已保存的节点数 / 哈希表大小
$$
1. 当负载因子大于等于 1 ，并且 Redis 没有在执行 `bgsave` 命令或者 `bgrewiteaof` 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作
2. 当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会**强制进行 rehash 操作**

#### 优点
1. 能以 O (1) 的复杂度快速查询数据

---

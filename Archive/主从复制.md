---
aliases: []
area: redis
project: 
date: 2023-08-03 16:26
tags: []
---
---
#### Content
Redis 提供了**主从复制模式**来避免避免单点故障，将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务
![[Pasted image 20230803162806.png]]
这个模式可以保证多台服务器的数据一致性，且主从服务器之间采用的是「读写分离」的方式

主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令

#### 第一次同步
多台服务器之间要通过什么方式来确定谁是主服务器，或者谁是从服务器呢？

我们可以使用 replicaof（Redis 5.0 之前使用 slaveof）命令形成主服务器和从服务器的关系。

比如，现在有服务器 A 和服务器 B，我们在服务器 B 上执行下面这条命令：
```cpp
// 服务器 B 执行这条命令
replicaof <服务器 A 的 IP 地址> <服务器 A 的 Redis 端口号>
```

服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步，这个过程分为三个阶段：
1. 建立连接、协商同步
    用来同步主从服务器的 **runID**
1. 主服务器同步数据给从服务器
    通过生成 RDB 的方式来同步数据，由于 RDB 持久化是后台执行不阻塞主进程，因此在 **「主服务器生成 RDB、主服务器发送 RDB 文件、从服务器加载 RDB 文件」** 三个时间段内主服务器还会处理相关的命令，为了使主从服务器保持一致，会将这三个时间段内的命令写入到缓冲区，当收到从服务器的确认消息后，将缓冲区里的写命令同步到从服务器
1. 主服务器发送新写操作命令给从服务器

#### 命令传播
主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接，后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。

而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。

上面的这个过程被称为**基于长连接的命令传播**

#### 分摊主服务器压力
主从服务器在第一次数据同步的过程中，主服务器会做两件耗时的操作：**生成 RDB 文件**和**传输 RDB 文件**

主服务器是可以有多个从服务器的，如果从服务器数量非常多，而且都与主服务器进行全量同步的话，就会带来**两个问题**：
1. 由于是通过 bgsave 命令来生成 RDB 文件的，那么主服务器就会忙于使用 fork () 创建子进程，如果主服务器的内存数据非大，在执行 fork () 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求
1. 传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响

为了解决这个问题，Redis 可以让从服务器有自己的从服务器，我们可以把拥有从服务器的从服务器当作经理角色，它不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器的形式将数据同步给从服务器，组织形式如下图：
![[Pasted image 20230803164458.png]]

> [!info] 主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器

#### 增量复制
主从服务器在完成第一次同步后，就会基于长连接进行命令传播。

如果主从服务器间的网络连接断开了，那么就无法进行命令传播了，这时从服务器的数据就没办法和主服务器保持一致了，客户端就可能从「从服务器」读到旧的数据

在 Redis 2.8 之前，如果主从服务器在命令同步时出现了网络断开又恢复的情况，从服务器就会和主服务器重新进行一次全量复制，很明显这样的开销太大了，必须要改进一波。

所以，从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用**增量复制**的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器

> [!faq] 增量复制是怎么实现的？
> 1. 从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1
> 2. 主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据
> 3. 然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令

> [!faq] 主服务器怎么知道要将哪些增量数据发送给从服务器呢？
> **repl_backlog_buffer**，是一个「环形」缓冲区，用于主从服务器断连后，从中找到差异的数据
> **replication_offset**，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 `master_repl_offset` 来记录自己「写」到的位置，从服务器使用 `slave_repl_offset` 来记录自己「读」到的位置

网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：
- 如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用**增量同步**的方式
- 如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用全量同步的方式

repl_backlog_buffer 缓行缓冲区的默认大小是 1M，并且由于它是一个环形缓冲区，所以当缓冲区写满后，主服务器继续写入的话，就会覆盖之前的数据。因此，当主服务器的写入速度远超于从服务器的读取速度，缓冲区的数据一下就会被覆盖。

那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用**全量同步**，这个方式比增量同步的性能损耗要大很多。

因此，为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式

> [!faq] repl_backlog_buffer 环形缓冲区大小怎么确定呢？
> $repl\_backlog\_size = second * write\_size\_per\_second$
> - **second** 为从服务器断线后重新连接上主服务器所需的平均时间 (以秒计算)
> - **write_size_per_second** 则是主服务器平均每秒产生的写命令数据量大小

#### 面试题
##### 怎么判断 Redis 某个节点是否正常工作？
Redis 判断节点是否正常工作，基本都是通过互相的 ping-pong 心态检测机制，如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接

Redis 主从节点发送的心态间隔是不一样的，而且作用也有一点区别：
- Redis 主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态，可通过参数 repl-ping-slave-period 控制发送频率
- Redis 从节点每隔 1 秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量，目的是为了：**实时监测主从节点网络状态**和**上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据**

##### 主从复制架构中，过期 key 如何处理？
主节点处理了一个 key 或者通过淘汰算法淘汰了一个 key，这个时间主节点模拟一条 del 命令发送给从节点，从节点收到该命令后，就进行删除 key 的操作

##### Redis 是同步复制还是异步复制？
Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点

##### 主从复制中两个 Buffer (replication buffer 、repl backlog buffer)有什么区别？
**出现的阶段不一样：**
- repl backlog buffer 是在增量复制阶段出现，一个主节点只分配一个 repl backlog buffer
- replication buffer 是在全量复制阶段和增量复制阶段都会出现，主节点会给每个新连接的从节点，分配一个 replication buffer

**这两个 Buffer 都有大小限制的，当缓冲区满了之后，发生的事情不一样：**
- 当 repl backlog buffer 满了，因为是环形结构，会直接覆盖起始位置数据
- 当 replication buffer 满了，会导致连接断开，删除缓存，从节点重新连接，重新开始全量复制

##### 如何应对主从数据不一致？
> [!faq] 为什么会出现主从数据不一致？
> - 主从数据不一致，就是指客户端从从节点中读取到的值和主节点中的最新值并不一致
> - 之所以会出现主从数据不一致的现象，是因为主从节点间的命令复制是异步进行的，所以无法实现强一致性保证（主从数据时时刻刻保持一致）
> - 总的来说，在主从节点命令传播阶段，主节点收到新的写命令后，会发送给从节点。但是，主节点并不会等到从节点实际执行完命令后，再把结果返回给客户端，而是主节点自己在本地执行完命令后，就会向客户端返回结果了。如果从节点还没有执行主节点同步过来的命令，主从节点间的数据就不一致了

> [!faq] 如何如何应对主从数据不一致？
> **第一种方法**，尽量保证主从节点间的网络连接状况良好，避免主从节点在不同的机房
> **第二种方法**，可以开发一个外部程序来监控主从节点间的复制进度
> - Redis 的 INFO replication 命令可以查看主节点接收写命令的进度信息（master_repl_offset）和从节点复制写命令的进度信息（slave_repl_offset），所以，我们就可以开发一个监控程序，先用 INFO replication 命令查到主、从节点的进度，然后，我们用 master_repl_offset 减去 slave_repl_offset，这样就能得到从节点和主节点间的复制进度差值了
> - 如果某个从节点的进度差值大于我们预设的阈值，我们可以让客户端不再和这个从节点连接进行数据读取，这样就可以减少读到不一致数据的情况。不过，为了避免出现客户端和所有从节点都不能连接的情况，我们需要把复制进度差值的阈值设置得大一些

##### 主从切换如何减少数据丢失？
主从切换过程中，产生数据丢失的情况有两种：
- 异步复制同步丢失
- 集群产生脑裂数据丢失

> [!warning] 我们不可能保证数据完全不丢失，只能做到使得尽量少的数据丢失

**异步复制同步丢失**
对于 Redis 主节点与从节点之间的数据复制，是异步复制的，当客户端发送写请求给主节点的时候，客户端会返回 ok，接着主节点将写请求异步同步给各个从节点，但是如果此时主节点还没来得及同步给从节点时发生了断电，那么主节点内存中的数据会丢失

**集群产生脑裂数据丢失**
在 Redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作

如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程 A），此时这些数据被主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的

这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在从节点中选举出一个 leeder 作为主节点，这时集群就有两个主节点了 —— **脑裂**

这时候网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前**客户端在过程 A 写入的数据就会丢失了**，也就是集群产生脑裂数据丢失的问题

> [!faq] 减少脑裂的数据丢的方案
> 当主节点发现**「从节点下线的数量太多」** ，或者**「网络延迟太大」** 的时候，那么主节点会禁止写操作，直接把错误返回给客户端
> `min-slaves-to-write x`，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。
> `min-slaves-max-lag x`，主从数据复制和同步的延迟不能超过 x 秒，如果主从同步的延迟超过 x 秒，主节点会禁止写数据

##### 主从如何做到故障自动切换？
主节点挂了，从节点是无法自动升级为主节点的，这个过程需要人工处理，在此期间 Redis 无法对外提供写操作

Redis 哨兵机制就登场了，哨兵在发现主节点出现故障时，由哨兵自动完成故障发现和故障转移，并通知给应用方，从而实现高可用性


---

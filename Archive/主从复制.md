---
aliases: []
area: redis
project: 
date: 2023-08-03 16:26
tags: []
---
---
#### Content
Redis 提供了**主从复制模式**来避免避免单点故障，将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务
![[Pasted image 20230803162806.png]]
这个模式可以保证多台服务器的数据一致性，且主从服务器之间采用的是「读写分离」的方式

主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令

#### 第一次同步
多台服务器之间要通过什么方式来确定谁是主服务器，或者谁是从服务器呢？

我们可以使用 replicaof（Redis 5.0 之前使用 slaveof）命令形成主服务器和从服务器的关系。

比如，现在有服务器 A 和服务器 B，我们在服务器 B 上执行下面这条命令：
```cpp
// 服务器 B 执行这条命令
replicaof <服务器 A 的 IP 地址> <服务器 A 的 Redis 端口号>
```

服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步，这个过程分为三个阶段：
1. 建立连接、协商同步
    用来同步主从服务器的 **runID**
1. 主服务器同步数据给从服务器
    通过生成 RDB 的方式来同步数据，由于 RDB 持久化是后台执行不阻塞主进程，因此在 **「主服务器生成 RDB、主服务器发送 RDB 文件、从服务器加载 RDB 文件」** 三个时间段内主服务器还会处理相关的命令，为了使主从服务器保持一致，会将这三个时间段内的命令写入到缓冲区，当收到从服务器的确认消息后，将缓冲区里的写命令同步到从服务器
1. 主服务器发送新写操作命令给从服务器

#### 命令传播
主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接，后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。

而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。

上面的这个过程被称为**基于长连接的命令传播**

#### 分摊主服务器压力
主从服务器在第一次数据同步的过程中，主服务器会做两件耗时的操作：**生成 RDB 文件**和**传输 RDB 文件**

主服务器是可以有多个从服务器的，如果从服务器数量非常多，而且都与主服务器进行全量同步的话，就会带来**两个问题**：
1. 由于是通过 bgsave 命令来生成 RDB 文件的，那么主服务器就会忙于使用 fork () 创建子进程，如果主服务器的内存数据非大，在执行 fork () 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求
1. 传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响

为了解决这个问题，Redis 可以让从服务器有自己的从服务器，我们可以把拥有从服务器的从服务器当作经理角色，它不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器的形式将数据同步给从服务器，组织形式如下图：
![[Pasted image 20230803164458.png]]

> [!info] 主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器

#### 增量复制
主从服务器在完成第一次同步后，就会基于长连接进行命令传播。

如果主从服务器间的网络连接断开了，那么就无法进行命令传播了，这时从服务器的数据就没办法和主服务器保持一致了，客户端就可能从「从服务器」读到旧的数据

在 Redis 2.8 之前，如果主从服务器在命令同步时出现了网络断开又恢复的情况，从服务器就会和主服务器重新进行一次全量复制，很明显这样的开销太大了，必须要改进一波。

所以，从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用**增量复制**的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器

> [!faq] 增量复制是怎么实现的？
> 1. 从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1
> 2. 主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据
> 3. 然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令

> [!faq] 主服务器怎么知道要将哪些增量数据发送给从服务器呢？
> **repl_backlog_buffer**，是一个「环形」缓冲区，用于主从服务器断连后，从中找到差异的数据
> **replication_offset**，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 `master_repl_offset` 来记录自己「写」到的位置，从服务器使用 `slave_repl_offset` 来记录自己「读」到的位置

---

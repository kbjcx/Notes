---
aliases: [SDS]
area: redis
project: 
date: 2023-08-02 16:30
tags: []
---
---
#### Content
Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS

- SDS 结构设计
![[Pasted image 20230802163504.png]]

结构中的每个成员变量分别介绍下：
- **len**，记录了字符串长度。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。
- **alloc**，分配给字符数组的空间长度。这样在修改字符串的时候，可以通过 alloc - len 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。
- **flags**，用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。
- **buf[ ]**，字符数组，用来保存实际数据。不仅可以保存字符串，也可以保存二进制数据

#### 优点
1. O（1）复杂度获取字符串长度
2. 二进制安全
    SDS 不需要用 `“\0” ` 字符来标识字符串结尾了，而是有个专门的 len 成员变量来记录长度，所以可存储包含 `“\0”` 的数据
3. 不会发生缓冲区溢出
    当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小，以满足修改所需的大小
4. 节省内存空间
     Redis 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64
     SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间
5. 兼容部分 C 字符串函数

#### 空间预分配
- 如果对 SDS 进行修改之后，SDS 的长度（也即是 `len` 属性的值）将小于 `1MB`，那么程序分配和 `len` 属性同样大小的未使用空间，这时 SDS `len` 属性的值将和 `alloc - len` 属性的值相同
- 如果对 SDS 进行修改之后，SDS 的长度将大于等于 `1MB`，那么程序会分配 1MB 的未使用空间, 即 SDS 的 `free` 为 `1MB`

---

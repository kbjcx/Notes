---
aliases: []
area: 计算机网络
project: 
date: 2023-06-13 20:08
tags: []
---
---
#### Description
> [!note] TCP 通过序列号、确认应答、重发控制、连接管理以及窗口控制来实现可靠性传输

##### 重传机制
- TCP 通过重传机制来实现网络丢包的问题
###### 超时重传
重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传

- TCP 会在一下两种情况下发生超时重传：
    1. 数据包丢失
    2. 确认应答丢失

- 当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差
- 当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发

- **<font color="#0593A2">超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</font>**

- RTO 的时间往往是动态变化的，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况

- 如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是**<font color="#0593A2">超时间隔加倍</font>**

###### 快速重传
- **<font color="#0593A2">不以时间为驱动，以数据驱动重传</font>**
- 快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段
- 但是快速重传是的一个问题是，重传确认号所指向的报文还是之后的所有报文

###### SACK (选择性确认）
- 这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据

###### Duplicate SACK (D-SACK)
- 使用了 SACK 来告诉「发送方」有哪些数据被重复接收了
- 可见，D-SACK 有这么几个好处：
    1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了
    2. 可以知道是不是「发送方」的数据包被网络延迟了
    3. 可以知道网络中是不是把「发送方」的数据包给复制了

> [!note] ACK 报文丢失一般可以通过**<font color="#0593A2">累计确认</font>**来判断

##### 滑动窗口
- 窗口大小就是指**<font color="#0593A2">窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值</font>**
- 窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除
- 发送方的滑动窗口:
![[Pasted image 20230613205021.png]]
- SND. WND: 表示滑动窗口的大小
- SND. UNA: 指向已发送但未确认的第一个字节的序列号
- SND. NXT: 指向未发送但在可发送范围的第一个字节的序列号
- 未发送但在超过接收方处理范围的第一个字节的序列号用 SND. UNA+SND. WND 表示

- 接收方的滑动窗口
![[Pasted image 20230613210033.png]]
- RCV. WND: 表示接收窗口的大小, 会通告给发送方
- RCV. NXT: 指向期望从发送方发送来的下一个字节的序列号 (即未收到数据但在可接收范围的第一个字节的序列号)
- 不可以接收数据的第一个字节的序列号由 RCV. NXT + RCV. WND 得到

##### 流量控制
- 发送方不能无脑的发数据给接收方，要考虑接收方处理能力, 如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费
- **<font color="#0593A2">流量控制</font>**可以让发送方根据接收方的实际接受能力控制发送的数据数量

- 如果操作系统更改接收方的缓存大小后没有及时通知到发送方, 那么发送方可能会按照自身的可用窗口发送一个无法接收的数据造成数据丢失
- 因此, 不允许在缩减窗口的同时减小缓存, 应该先缩减窗口, 过段时间再减小缓存

- **<font color="#0593A2">窗口关闭</font>**:
窗口关闭发生在接收端服务繁忙没有及时处理接收的数据, 导致数据堆积, 发送窗口缩减到 0.
只要接收方处理完数据, 发送一个窗口非 0 的 ACK 报文即可解决窗口关闭的状态.
但是若这个 ACK 报文在网络传输中丢失, 那么就会陷入一个死锁的状态.
TCP 通过定时的**窗口探测报文**来检测对方的窗口大小变化, 数次尝试之后若依然为 0, 则可以发送 RST 关闭连接.

- **<font color="#0593A2">糊涂窗口综合征</font>**:
如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症
为了发送几个字节的数据搭上了 TCP+IP 头部 40 字节的开销, 得不偿失
只需要解决两件事: 1. 接收方不通告小窗口 2. 发送方不发送小数据
1. 如何让接收方不通告小数据?
当「窗口大小」小于 MSS 和缓存区一半中的最小值时, 会向发送方通告为 0 窗口
2. 发送方如何避免发送小数据?
使用 Nagle 算法, 满足以下两个条件之一时才会发送数据, 否则就一直堆积:
    - **<font color="#0593A2">条件一: </font>**等到窗口大小大于等于 MSS 并且数据大小大于等于 MSS
    - **<font color="#0593A2">条件二: </font>**收到之前发送的数据的 ACK 报文
> [!attention] 要避免糊涂窗口综合征, 需要发送方开启 Nagle 算法的同时接收方采取不通告小窗口的策略

##### 拥塞控制
- 在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大
- **拥塞窗口 cwnd** 是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的
- 发送窗口取拥塞窗口与接收窗口中的最小值
- 只要触发了超时重传机制就可以认为网络发生了拥堵
- 拥塞控制主要有 4 个算法: 慢启动, 拥塞避免, 拥塞发生, 快速恢复
- **<font color="#0593A2">慢启动: </font>**
    - **当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1**
    - 有一个叫慢启动门限 ssthresh （slow start threshold）状态变量
    - 当 cwnd < ssthresh 时，使用慢启动算法。
    - 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」





---
#### Source
- [4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0)
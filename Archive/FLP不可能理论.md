---
aliases: []
area: 分布式
project: 
date: 2023-08-06 19:32
tags: []
---
---
#### Content
FLP 不可能理论证明了在一个完全异步的系统中，即使只有一个节点出现了故障，也不存在一个算法使系统达成共识。即对于一个完全异步的系统，我们不可能同时拥有安全性、活性和容错性。

算法流程中有三个最坏的结果导致共识算法无法实现：
1. 一个完全异步的系统
2. 系统发生了故障
3. 不可能有一个具备安全性、活性和容错性的共识算法

针对这些最坏的情况，可以找到一些方法，尽可能绕过 FLP 不可能定理，从而满足大部分情况下都能达成共识，找到公式问题工程上的解：
1. 故障屏蔽
2. 使用故障检测器
3. 使用随机性算法

#### 故障屏蔽
既然在异步系统中无法达成共识，那么我们可以想办法将异步系统转换为同步系统，故障屏蔽就是第一种转换方法。故障屏蔽假设故障的进程最终会恢复，并找到一种重新加入分布式系统的方式。如果没有收到来自某个进程的消息，就一直等待，直到收到预期的消息。

常见的一种方法是，如果一个进程崩溃，那么它会被重启（自动重启或由系统管理员重启），进程在持久化存储中保留了足够多的信息，以便在崩溃和重启时能够利用这些数据继续工作。换句话说，故障的进程也能够像正确的进程一样工作，只是它有时候需要很长时间来执行一个恢复处理。例如，在两阶段提交协议（见第 5 章）中使用了持久化存储，让进程能够从故障中重新恢复状态。

#### 使用故障检测器
将异步系统转换为同步系统的第二种方法是使用故障检测器。进程可以通过某种故障检测器来确认没有响应的进程是否已经发生故障。一种最常见的故障检测器是超时故障检测器，即如果进程在一定时间内没有响应，那么即便该进程并没有发生故障，我们依然认为该进程已经失效。但是，这种方法要求故障检测器是精确的。如果故障检测器不精确，那么系统可能经常放弃

一个正常的进程。例如超时故障检测器，如果超时时间设定得很长，那么进程就需要等待（并且不能执行任何工作)较长的时间才能得出节点发生故障的结论。如果这种方法处理不好，甚至有可能导致网络分区。

故障检测器必须拥有两个属性：
1. **完全性：** 每一个故障的进程都会被每一个正确的进程怀疑
2. **精确性：** 正确的进程不会被别的进程怀疑

该算法论文证明了即使使用“不完美的”故障检测器，只要通信可靠，失效的进程不超过 $N/2$，那么依然可以用来解决共识问题。我们不需要实现一个完全满足完全性和精确性的故障检测器，只需要一个最终弱故障检测器即可，该检测器具有如下性质：
1. **最终弱完全性：**
    每一个故障的进程最终都会被一些正确的进程检测到
1. **最终弱精确性：**
    经过一段时间后，一个正确的进程不会被其他正确的进程怀疑

超时故障检测器能够根据观察到的进程的响应时间调节它的超时时间。如果一个进程或者检测器到进程之间的连接很慢那么适当增加超时时间，错误怀疑一个进程的情况将变得很少。从实用角度来看，这样的弱故障检测器与理想的最终弱故障检测器十分接近。进程正确运行时，网络延迟也会导致故障检测器错误怀疑进程发生了故障，但最终故障检测器能够检测到进程真的发生了故障

#### 使用随机性算法




---
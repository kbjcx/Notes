---
aliases: [SDS]
area: redis
project: 
date: 2023-07-21 22:28
tags: []
---
---
#### Description
- 用 `sdshdr` 结构体来存储字符串, 定义如下:
```cpp
struct sdshdr {
    int len; // buffer中已使用的长度, 即字符串的长度
    int free; // 剩余的字节大小
    char buf[]; // 存储字符串的字符数组
};
```

> [!attention] 
> `SDS` 的 `buf` 中存储时依然采取了 C 字符串的表示方法, 在字符串末尾添加 `\0` 来表示结束, 这是为了能够兼容部分 C 字符串函数采取的措施. 并且, 插入 `\0` 的过程是透明的, 由内部实现自动添加, 不会占据 `len` 和 `free` 的空间, 因此 `buf` 的实际长度为 `len + free + 1`
![[Pasted image 20230721223407.png]]

##### SDS 相对于 C 字符串的优点
1. 常数复杂度获取字符串长度
2. 杜绝缓冲区溢出
    采用动态分配字符数组长度来杜绝了缓冲区溢出
3. 减少修改字符串时带来的内存重新分配次数
    C 字符串在进行拼接或者截断操作时 , 往往需要进行空间的分配和释放, redis 工作于频繁修改的环境中, 因此采用 SDS 减少字符串修改时的内存重新分配次数
4. 二进制安全
    SDS 通过 len 来确定字符串的长度, 因此字符串中间可以存在 `\0`, 

##### 空间预分配
- 如果对 SDS 进行修改之后，SDS 的长度（也即是 `len` 属性的值）将小于 `1MB`，那么程序分配和 `len` 属性同样大小的未使用空间，这时 SDS `len` 属性的值将和 `free` 属性的值相同
- 如果对 SDS 进行修改之后，SDS 的长度将大于等于 `1MB`，那么程序会分配1MB 的未使用空间, 即 SDS 的 `free` 为 `1MB`

##### 惰性空间释放
- 当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 `free` 属性将这些字节的数量记录起来，并等待将来使用
---
#### Source

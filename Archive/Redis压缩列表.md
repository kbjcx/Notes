---
aliases: [压缩列表]
area: redis
project: 
date: 2023-08-01 15:16
tags: [TODO]
---
---
#### Content
**压缩列表结构设计**
压缩列表是 Redis 为了节约内存而开发的，它是由连续内存块组成的顺序型数据结构，有点类似于数组

![[Pasted image 20230802173249.png]]

- **zlbytes**，记录整个压缩列表占用对内存字节数；
- **zltail**，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；
- **zllen**，记录压缩列表包含的节点数量；
- **zlend**，标记压缩列表的结束点，固定值 `0xFF`（十进制 255）

> [!important] 
> 在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（**zllen**）的长度直接定位，复杂度是 O (1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O (N) 了，因此**压缩列表不适合保存过多的元素**

压缩列表节点（entry）的构成如下:

![[Pasted image 20230802182011.png]]

- **prevlen**，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；
    - 如果前一个节点的长度小于 254 字节，那么 **prevlen** 属性需要用 1 字节的空间来保存这个长度值；
    - 如果前一个节点的长度大于等于 254 字节，那么 **prevlen** 属性需要用 5 字节的空间来保存这个长度值
- **encoding**，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。
- **data**，记录了当前节点的实际数据，类型和长度都由 encoding 决定；

压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销


---

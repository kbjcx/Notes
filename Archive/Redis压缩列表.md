---
aliases: [压缩列表, ziplist]
area: redis
project: 
date: 2023-08-01 15:16
tags: []
---
---
#### Content
**压缩列表结构设计**
压缩列表是 Redis 为了节约内存而开发的，它是由连续内存块组成的顺序型数据结构，有点类似于数组

![[Pasted image 20230802173249.png]]

- **zlbytes**，记录整个压缩列表占用对内存字节数；
- **zltail**，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；
- **zllen**，记录压缩列表包含的节点数量；
- **zlend**，标记压缩列表的结束点，固定值 `0xFF`（十进制 255）

> [!important] 
> 在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（**zllen**）的长度直接定位，复杂度是 O (1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O (N) 了，因此**压缩列表不适合保存过多的元素**

压缩列表节点（entry）的构成如下:

![[Pasted image 20230802182011.png]]

- **prevlen**，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；
    - 如果前一个节点的长度小于 ==254 字节==，那么 **prevlen** 属性需要用 **1 字节**的空间来保存这个长度值；
    - 如果前一个节点的长度大于等于 ==254 字节==，那么 **prevlen** 属性需要用 **5 字节**的空间来保存这个长度值
- **encoding**，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数
    ![[Pasted image 20230802182404.png]]
- **data**，记录了当前节点的实际数据，类型和长度都由 encoding 决定；

#### 连锁更新
> [!important] 
> 压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 **prevlen** 占用空间都发生变化，从而引起==「连锁更新」==问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降

假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：

![[Pasted image 20230802182542.png]]

因为这些节点长度值小于 254 字节，所以 **prevlen** 属性需要用 1 字节的空间来保存这个长度值
这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：

![[Pasted image 20230802182631.png]]

因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小，导致后续所有节点都需要进行更新

#### 优点
1. 压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销

#### 缺点
1. 空间扩展操作也就是重新分配内存，因此==连锁更新==一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能
2. 不能保存过多的元素，否则查询效率就会降低

---

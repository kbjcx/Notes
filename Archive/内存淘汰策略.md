---
aliases: []
area: redis
project: 
date: 2023-08-03 15:20
tags: []
---
---
#### Content
在配置文件 redis.conf 中，可以通过参数 `maxmemory <bytes>` 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。不同位数的操作系统，`maxmemory` 的默认值是不同的：
- 在 **64 位操作系统**中，`maxmemory` 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。
- 在 **32 位操作系统**中，`maxmemory` 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃

#### 内存淘汰策略
##### 不进行数据淘汰的策略
noeviction（Redis3.0 之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，则会触发 OOM，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作

##### 进行数据淘汰的策略
进行数据淘汰的策略又被分为两种，「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」

**在设置了过期时间的数据中进行淘汰：**
1. **volatile-random**：随机淘汰设置了过期时间的任意键值
2. **volatile-ttl**：优先淘汰更早过期的键值
3. **volatile-lru**（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值
4. **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值

**在所有数据范围内进行淘汰：**
- **allkeys-random**：随机淘汰任意键值
- **allkeys-lru**：淘汰整个键值中最久未使用的键值
- **allkeys-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值

#### LRU 算法和 LFU 算法有什么区别？
LRU 全称是 Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据

传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素

> [!attention] 传统的 LRU 算法存在两个问题
> 1. 需要用链表管理所有的缓存数据，这会带来额外的空间开销
> 2. 当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能

##### Redis 是如何实现 LRU 算法的？
Redis 实现的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间

当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（==此值可配置==），然后淘汰最久没有使用的那个

**Redis 实现的 LRU 算法的优点：**
- 不用为所有的数据维护一个大链表，节省了空间占用
- 不用在每次数据访问时都移动链表项，提升了缓存的性能

> [!error] LRU 算法有一个问题
> 无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染

==在 Redis 4.0 之后引入了 LFU 算法来解决这个问题==

LFU 全称是 Least Frequently Used 翻译为最近最不常用，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”

所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些

##### Redis 是如何实现 LFU 算法的？
LFU 算法相比于 LRU 算法的实现，多记录了 **「数据的访问频次」** 的信息
```cpp
typedef struct redisObject {
    ...
      
    // 24 bits，用于记录对象的访问信息
    unsigned lru:24;  
    ...
} robj;
```

在 LRU 算法中，Redis 对象头的 24 bits 的 `lru` 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis 可以根据对象头中的 `lru` 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key
在 LFU 算法中，Redis 对象头的 24 bits 的 `lru` 字段被分成两段来存储，高 16bit 存储 ldt (Last Decrement Time)，低 8bit 存储 logc (Logistic Counter)
![[Pasted image 20230803161422.png]]

- **ldt** 是用来记录 key 的访问时间戳
- **logc** 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的 logc 初始值为 5

> [!attention] 
> - logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 logc 会随时间推移而衰减的
> - 在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟==前后访问时间的差距==有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据访问频率来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大

> [!faq] Redis 在访问 key 时，logc 是怎样变化的？
> 1. 先按照上次访问距离当前的时长，来对 logc 进行衰减
> 2. 再按照一定概率增加 logc 的值，如果 logc 越大的 key，它的 logc 就越难再增加




---

---
aliases: []
area: C++
project: 
date: 2023-07-29 11:37
tags: []
---
---
#### Description
##### `auto` 自动类型推导
- 推导规则
    - 不声明为指针或引用时，`auto` 的推导结果和初始表达式抛弃引用和 `const` 限定符后的类型一致
    - 当声明为指针或引用时，`auto` 的推导结果将保持初始化表达式的 `const` 属性
- `auto` 的限制
    - `auto` 不能在函数的参数中使用（`auto` 要求必须对变量进行初始化）
    - `auto` 不能作用于类的非静态成员变量中（因为 `auto` 需要在编译期确定类型，但是非静态成员变量在调用构造函数时才初始化）
    - `auto` 关键字不能用于定义数组（因为无法从 `{1, 2, 3, 4}` 中推导出类型）
    - `auto` 不能作用于模板参数（无法推导出模板类型）
##### `decltype` 类型推导
- `decltype` 通过表达式的类型进行推导，不要求初始化
- 推导规则 `decltype(exp)`
    - 推导非表达式: 类型则为 exp 同类型
    - 推导表达式: 根据表达式来判断, 先计算再推导, <font color="#0593A2">**将亡值**</font>: `T&&`, <font color="#0593A2">**左值**</font>: `T&`, <font color="#0593A2">**纯右值:**</font>: `T`
- 返回值类型后置，`auto` 和 `decltype` 合用
    ```cpp
    template <typename T, typename U>
    auto add(T t, U u) -> decltype(t + u) {
        return t + u;
    }   
    ```
##### 范围 `for` 循环
- 用于遍历序列式容器
##### 右值
1. 右值不可以取地址
1. 右值不可以直接修改
1. 右值只能放在等号右边
1. 右值往往是没有名称的
###### 右值引用 (右值引用是左值)
1. 必须进行初始化
2. 不能使用左值进行初始化
3. 可以对右值进行修改
###### 移动语义
- 避免拷贝实现所有权的转移, 避免浅拷贝带来的悬垂指针以及深拷贝的开销
###### 完美转发
- 传递参数为右值引用, 在内部进行函数调用时该参数就失去了右值属性, 因此通过 `std::forward<T>()` 来将参数的值以及左右值属性进行转发.
- 一般结合**万能引用**来使用, 万能引用用于类型推导, 包括模板参数、auto 关键字, `T&&` 既可以接收左值也可以接收右值, 推导出左值引用或是右值引用, 接受左值即为左值引用, 接收右值即为右值引用
##### [[智能指针]]
##### Lambda 表达式
```cpp
auto func = [捕获列表](参数列表)->返回值 {
    函数体
}

```
##### `constexpr/ constexpr if`
- 使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段
- `const` 和 `constexpr` 的区别
    - `const` 变量的初始化可以延长到运行时，而 `constexpr` 必须在编译期初始化
    - `constexpr` 声明中如果定义了一个指针，则仅对指针有效，与指针所指的对象无关
    - `constexpr` 需要与 `const` 共用才能实现常指针的定义
##### `nullptr`
- C++中 `nullptr` 被定义为空指针类型（`std::nullptr_t`），`NULL` 被定义为 `0`
- C 中 `NULL` 被定义为 `(void*)0`
- C++是强类型语言，不能把 `void*` 类型指针隐式转换为其他类型指针，因此使用 `NULL=0` 来代替 `NULL=(void*)0`
- 但是用 `NULL=0` 来表示空指针会在函数重载时发生错误，他会选择 `int` 类型的重载而非指针类型，因此引入空指针类型 `std::nullptr_t` 和 `nullptr` 来表示空指针
##### `override` 和 `final`
- 增强代码的可读性
##### `std::bind`
- 返回一个函数对象，并将其参数进行绑定
- 每个参数可以绑定到一个值或占位符
    - 如果绑定一个值，则返回的函数对象将始终使用该值作为参数
    - 如果绑定一个占位符，则返回的函数对象会转发一个传递给调用的参数（该参数的顺序号由占位符指定）
- 注意点
    - `bind` 预先绑定的参数需要传具体的变量或值进去，对于预先绑定的参数，是**pass-by-value**的。除非该参数被 `std::ref` 或者 `std::cref` 包装，才**pass-by-reference**
    - 对于不事先绑定的参数，需要传 `std::placeholders` 进去，从 `_1` 开始，依次递增。**placeholder**是**pass-by-reference**的
    - `bind` 的返回值是可调用实体，可以直接赋给 `std::function` 对象
    - 对于绑定的指针、引用类型的参数，使用者需要保证在可调用实体调用之前，这些参数是可用的
    - 类的 `this` 可以通过对象或者指针来绑定

##### `std::function`
- `std::function` 的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括**普通函数、Lambda 表达式、bind 表达式、函数指针以及其它函数对象**。`std::function` 对象是对 C++中现有的可调用实体的一种**类型安全**的包装（像函数指针这类可调用实体，是类型不安全的【因为函数指针可以转换为任意其他类型的函数指针】）
---

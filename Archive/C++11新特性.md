---
aliases: []
area: C++
project: 
date: 2023-07-29 11:37
tags: []
---
---
#### Description
##### `auto` 自动类型推导
- 推导规则
    - 不声明为指针或引用时，`auto` 的推导结果和初始表达式抛弃引用和 `const` 限定符后的类型一致
    - 当声明为指针或引用时，`auto` 的推导结果将保持初始化表达式的 `const` 属性
- `auto` 的限制
    - `auto` 不能在函数的参数中使用（`auto` 要求必须对变量进行初始化）
    - `auto` 不能作用于类的非静态成员变量中（因为 `auto` 需要在编译期确定类型，但是非静态成员变量在调用构造函数时才初始化）
    - `auto` 关键字不能用于定义数组（因为无法从 `{1, 2, 3, 4}` 中推导出类型）
    - `auto` 不能作用于模板参数（无法推导出模板类型）
##### `decltype` 类型推导
- `decltype` 通过表达式的类型进行推导，不要求初始化
- 推导规则 `decltype(exp)`
    - 推导非表达式: 类型则为 exp 同类型
    - 推导表达式: 根据表达式来判断, 先计算再推导, <font color="#0593A2">**将亡值**</font>: `T&&`, <font color="#0593A2">**左值**</font>: `T&`, <font color="#0593A2">**纯右值:**</font>: `T`
- 返回值类型后置，`auto` 和 `decltype` 合用
    ```cpp
    template <typename T, typename U>
    auto add(T t, U u) -> decltype(t + u) {
        return t + u;
    }   
    ```
##### 范围 `for` 循环
- 用于遍历序列式容器
##### 右值
1. 右值不可以取地址
1. 右值不可以直接修改
1. 右值只能放在等号右边
1. 右值往往是没有名称的
###### 右值引用 (右值引用是左值)
1. 必须进行初始化
2. 不能使用左值进行初始化
3. 可以对右值进行修改
###### 移动语义
- 避免拷贝实现所有权的转移, 避免浅拷贝带来的悬垂指针以及深拷贝的开销
###### 完美转发
- 传递参数为右值引用, 在内部进行函数调用时该参数就失去了右值属性, 因此通过 `std::forward<T>()` 来将参数的值以及左右值属性进行转发.
- 一般结合**万能引用**来使用, 万能引用用于类型推导, 包括模板参数、auto 关键字, `T&&` 既可以接收左值也可以接收右值, 推导出左值引用或是右值引用, 接受左值即为左值引用, 接收右值即为右值引用
##### [[智能指针]]
##### Lambda 表达式
```cpp
auto func = [捕获列表](参数列表)->返回值 {
    函数体
}

```
##### constexpr/ constexpr if

##### nullptr
##### override 和 final

---

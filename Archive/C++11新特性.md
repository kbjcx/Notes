---
aliases: []
area: C++
project: 
date: 2023-07-29 11:37
tags: []
---
---
#### Description
##### `auto` 自动类型推导
- 推导规则
    - 不声明为指针或引用时，`auto` 的推导结果和初始表达式抛弃引用和 `const` 限定符后的类型一致
    - 当声明为指针或引用时，`auto` 的推导结果将保持初始化表达式的 `const` 属性
- `auto` 的限制
    - `auto` 不能在函数的参数中使用（`auto` 要求必须对变量进行初始化）
    - `auto` 不能作用于类的非静态成员变量中（因为 `auto` 需要在编译期确定类型，但是非静态成员变量在调用构造函数时才初始化）
    - `auto` 关键字不能用于定义数组（因为无法从 `{1, 2, 3, 4}` 中推导出类型）
    - `auto` 不能作用于模板参数（无法推导出模板类型）
##### `decltype` 类型推导
- `decltype` 通过表达式的类型进行推导，不要求初始化
- 推导规则 `decltype(exp)`
    - 推导非表达式: 类型则为 exp 同类型
    - 推导表达式: 根据表达式来判断, 先计算再推导, <font color="#0593A2">**将亡值**</font>: `T&&`, <font color="#0593A2">**左值**</font>: `T&`, <font color="#0593A2">**纯右值:**</font>: `T`
- 返回值类型后置，`auto` 和 `decltype` 合用
    ```cpp
    template <typename T, typename U>
    auto add(T t, U u) -> decltype(t + u) {
        return t + u;
    }   
    ```
##### 范围 `for` 循环
- 用于遍历序列式容器
##### 右值引用和移动语义
1. 右值不可以取地址
1. 右值不可以直接修改
1. 右值只能放在等号右边
1. 右值往往是没有名称的
###### 右值引用
1. 必须进行初始化
2. 不能使用左值进行初始化
3. 可以对右值进行修改

##### [[智能指针]]
##### Lambda 表达式
##### constexpr/ constexpr if
##### nullptr
##### override 和 final

---

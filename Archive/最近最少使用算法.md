---
aliases: [LRU]
area: 操作系统
project: 
date: 2023-04-11 17:17
---
---
#### Description
> [!attention] **LRU**实现思路
> - 当访问的页在内存中, 直接将该页移动到链表头部
> - 当访问的也不在内存中, 不仅将该页加入链表头部, 并且移除链表尾部的页

- 越接近于链表尾部, 就表示内存页越不常访问, 这样操作系统在回收内存时能方便回收最不活跃的内存页, 即从链表尾部的页开始回收
- 传统的 LRU 算法的局限性: 
    1. **<font color="#0593A2">预读失效</font>**导致缓存命中率下降
    2. **<font color="#0593A2">缓存污染</font>**导致缓存命中率下降

**预读失效如何影响 LRU ?**
由[[预读机制]]加载进来的页都会被放到 LRU 链表的头部, 如果这些被预加载的数据部被访问, 就出现了不被访问的页出现在链表头部, 而淘汰了链表尾部可能是热点数据的页. 这样就会大大降低缓存命中率. 

**避免缓存失效的方法**
上述 LRU 受到预读失效影响的根本原因在于会将实际没有被访问的页放到链表的头部, 导致将可能处于活跃的页移出链表. 
因此 Linux 的 LRU 算法维护了两个链表: `active_list` 和 `inactive_list`
- `active_list` 活跃内存页链表, 这里存放的是最近访问过的内存页
- `inactive_list` 不活跃内存页链表, 这里存放的是很少被访问的内存页

在这种设计下, 只有真正被访问的页才会被放到 `active_list`, 而将预读机制预存的内存页放到 `inactive_list`, 移除 `inactive_list` 尾部的页. 这样的话 `active_list` 里的所有的页都会处于预加载的页前面, 也就不会出现预加载的页将活跃的页挤出链表的可能. 当 `active_list` 头部添加页后会将 `active_list` 尾部的页移到 `inactive_list` 头部.


---
#### Source
- [4.5 如何避免预读失效和缓存污染的问题？ | 小林coding](https://xiaolincoding.com/os/3_memory/cache_lru.html#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E9%80%A0%E6%88%90%E7%9A%84%E5%BD%B1%E5%93%8D)
---
aliases: [跳表, skiplist]
area: redis
project: 
date: 2023-08-02 12:19
tags: [TODO]
---
---
#### Zset 设计结构
zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询
```cpp
typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
```
Zset 对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致
Zset 对象能支持范围查询（如 **ZRANGEBYSCORE** 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 **ZSCORE** 操作），这是因为它同时采用了哈希表进行索引

#### 跳表设计结构
链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是 O (N)，于是就出现了跳表。跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，这样的好处是能快读定位数据
![[Pasted image 20230802204224.png]]

图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：
- L0 层级共有 5 个节点，分别是节点 1、2、3、4、5；
- L1 层级共有 3 个节点，分别是节点 2、3、5；
- L2 层级只有 1 个节点，也就是节点 3 

如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4

```cpp
typedef struct zskiplistNode {
    //Zset 对象的元素值
    sds ele;
    //元素权重值
    double score;
    //后向指针
    struct zskiplistNode *backward;
  
    //节点的level数组，保存每层上的前向指针和跨度
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;
```
Zset 对象要同时保存「元素」和「元素的权重」，对应到跳表节点结构里就是 `sds` 类型的 `ele` 变量和 `double` 类型的 `score` 变量
每个跳表节点都有一个后向指针（`struct zskiplistNode *backward`），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便
跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的 `zskiplistLevel` 结构体类型的 `level` 数组
`level` 数组中的每一个元素代表跳表的一层，也就是由 `zskiplistLevel` 结构体表示，比如 `leve[0]` 就表示第一层，`leve[1]` 就表示第二层。`zskiplistLevel` 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离
**跨度实际上是为了计算这个节点在跳表中的排位** ，因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位
**「跳表」结构体定义如下：**
```cpp
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
```
- **header，tail** 跳表的头尾节点，便于在 O (1)时间复杂度内访问跳表的头节点和尾节点；
- **length** 跳表的长度，便于在 O (1)时间复杂度获取跳表节点的数量；
- **level** 跳表的最大层数，便于在 O (1)时间复杂度获取跳表中层高最大的那个节点的层数量

#### 跳表节点查询过程
查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：
- 如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点
- 如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点

如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找

#### 跳表节点层数设置
跳表的相邻两层的节点数量的比例会影响跳表的查询性能
> [!note] 
> 跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O (logN)

> [!faq] 那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？
> 


---

---
aliases: [跳表, skiplist]
area: redis
project: 
date: 2023-08-02 12:19
tags: [TODO]
---
---
#### Content
跳表的优势是能支持平均 O (logN) 复杂度的节点查找
zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询
```cpp
typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
```
Zset 对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致
Zset 对象能支持范围查询（如 **ZRANGEBYSCORE** 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 **ZSCORE** 操作），这是因为它同时采用了哈希表进行索引

**跳表设计结构：**
链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是 O (N)，于是就出现了跳表。跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，这样的好处是能快读定位数据
![[Pasted image 20230802204224.png]]

图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：
- L0 层级共有 5 个节点，分别是节点 1、2、3、4、5；
- L1 层级共有 3 个节点，分别是节点 2、3、5；
- L2 层级只有 1 个节点，也就是节点 3 

如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4

```cpp
typedef struct zskiplistNode {
    //Zset 对象的元素值
    sds ele;
    //元素权重值
    double score;
    //后向指针
    struct zskiplistNode *backward;
  
    //节点的level数组，保存每层上的前向指针和跨度
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;
```
Zset 对象要同时保存「元素」和「元素的权重」，对应到跳表节点结构里就是 `sds` 类型的 `ele` 变量和 `double` 类型的 `score` 变量
每个跳表节点都有一个后向指针（`struct zskiplistNode *backward`），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便
跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的 `zskiplistLevel` 结构体类型的 `level` 数组
`level` 数组中的每一个元素代表跳表的一层，也就是由 `zskiplistLevel` 结构体表示，比如 `leve[0]` 就表示第一层，`leve[1]` 就表示第二层。`zskiplistLevel` 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离
**跨度实际上是为了计算这个节点在跳表中的排位** ，因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位



---

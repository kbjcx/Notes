---
aliases: [跳表, skiplist]
area: redis
project: 
date: 2023-08-02 12:19
tags: []
---
---
#### Zset 设计结构
[[Redis.Zset|Zset]] 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询
```cpp
typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
```
Zset 对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致

Zset 对象能支持范围查询（如 **ZRANGEBYSCORE** 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 **ZSCORE** 操作），这是因为它同时采用了哈希表进行索引

#### 跳表设计结构
链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是 O (N)，于是就出现了跳表。跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，这样的好处是能快读定位数据

![[Pasted image 20230802204224.png]]

图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：
- L0 层级共有 5 个节点，分别是节点 1、2、3、4、5；
- L1 层级共有 3 个节点，分别是节点 2、3、5；
- L2 层级只有 1 个节点，也就是节点 3 

如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4

```cpp
typedef struct zskiplistNode {
    //Zset 对象的元素值
    sds ele;
    //元素权重值
    double score;
    //后向指针
    struct zskiplistNode *backward;
  
    //节点的level数组，保存每层上的前向指针和跨度
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;
```
Zset 对象要同时保存「元素」和「元素的权重」，对应到跳表节点结构里就是 `sds` 类型的 `ele` 变量和 `double` 类型的 `score` 变量

每个跳表节点都有一个后向指针（`struct zskiplistNode *backward`），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便

跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的 `zskiplistLevel` 结构体类型的 `level` 数组

`level` 数组中的每一个元素代表跳表的一层，也就是由 `zskiplistLevel` 结构体表示，比如 `leve[0]` 就表示第一层，`leve[1]` 就表示第二层。`zskiplistLevel` 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离

**跨度实际上是为了计算这个节点在跳表中的排位** ，因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位

**「跳表」结构体定义如下：**
```cpp
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
```
- **header，tail** 跳表的头尾节点，便于在 O (1)时间复杂度内访问跳表的头节点和尾节点；
- **length** 跳表的长度，便于在 O (1)时间复杂度获取跳表节点的数量；
- **level** 跳表的最大层数，便于在 O (1)时间复杂度获取跳表中层高最大的那个节点的层数量

#### 跳表节点查询过程
查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：
- 如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点
- 如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点

如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找

#### 跳表节点层数设置
跳表的相邻两层的节点数量的比例会影响跳表的查询性能
> [!note] 
> 跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O (logN)

> [!faq] 那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？
> - 如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销
> - 跳表在创建节点的时候，**随机生成每个节点的层数**，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况
> - 跳表在创建节点时候，会生成范围为 $[0, 1]$ 的一个随机数，如果这个随机数小于 $0.25$（相当于概率 $25\%$），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 $0.25$ 结束，最终确定该节点的层数
> - 层数越高，概率越低，层高最大限制是 64

#### 为什么用跳表而不用平衡树？
1. **从内存占用上来比较，跳表比平衡树更灵活一些**。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 $1/(1-p)$，具体取决于参数 $p$ 的大小。如果像 Redis 里的实现一样，取 $p=1/4$，那么平均每个节点包含 $1.33$ 个指针，比平衡树更有优势
1. **在做范围查找的时候，跳表比平衡树操作要简单**。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现
1. **从算法实现难度上来比较，跳表比平衡树要简单得多**。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速

#### 优点
1. 跳表的优势是能支持平均 O (logN) 复杂度的节点查找

---

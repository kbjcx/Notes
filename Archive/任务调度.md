---
aliases: [进程调度, 线程调度]
area: 操作系统
project: 
date: 2023-04-10 19:22
---
---
#### Description
根据如何处理时钟中断可以将调度算法分为两类: 
- **<font color="#0593A2">非抢占式调度: </font>**
  挑选一个进程, 直到其**<font color="#0593A2">被阻塞或者运行结束</font>**才会去调用另一个进程, 也就是不会去处理时钟中断
- **<font color="#0593A2">抢占式调度: </font>**
  挑选一个进程, 然后让该进程只运行一段时间, 如果该进程在该时段结束时仍在运行, 则会把该进程挂起, 接着再从就绪链表中挑选另一个进程. 这种方式通过时间末端触发中断来进行调度, 称为**<font color="#0593A2">时间片机制</font>**


Linux 中进程/线程任务具有优先级之分, 为了让高优先级的任务被尽早执行, 分出了以下三种调度类: 

|  调度类  |     调度器      |         调度策略         | 运行队列 |
|:--------|:---------------:|:------------------------:|:--------:|
| Deadline | Deadline 调度器 |     `SCHED_DEADLINE`     |  dl_rq   |
| Realtime |    RT 调度器    | `SCHED_FIFO`, `SCHED_RR` |  rt_rq   |
|Fair|CFS 调度器| `SCHED_NORMAL`, `SCHED_BATCH` |cfs_rq|

- Deadline 和 Realtime 调度类用于<font color="#0593A2">实时任务 (优先级 0~99)</font>
    - `SCHED_DEADLINE`: 按照距离当前时间点最近的 deadline 的任务进行优先调度
    - `SCHED_FIFO`: 对于优先级相同的任务采取先来先服务, 但是优先级高的任务可以抢占优先级低的任务
    - `SCHED_RR`: 对于优先级相同的任务采取时间片的方式轮流运行, 用完当前时间片的任务会被放到任务队尾, 但是高优先级任务可以抢占低优先级任务
- Fair 类用于<font color="#0593A2">普通任务 (优先级 100~139)</font>, 都是由[[完全公平调度|CFS]]调度器进行管理
    - `SCHED_NORMAL`: 用于普通任务调度
    - `SCHED_BATCH`: 后台任务调度策略, 在不影响其他需要交互的任务的前提下, 可以适当降低它的优先级
---
#### Source
- [2.5 CPU 是如何执行任务的？ | 小林coding](https://xiaolincoding.com/os/1_hardware/how_cpu_deal_task.html#%E5%88%86%E6%9E%90%E4%BC%AA%E5%85%B1%E4%BA%AB%E7%9A%84%E9%97%AE%E9%A2%98)
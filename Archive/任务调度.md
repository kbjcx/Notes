---
aliases: [进程调度, 线程调度]
area: 操作系统
project: 
date: 2023-04-10 19:22
---
---
#### Description
根据如何处理时钟中断可以将调度算法分为两类: 
- **<font color="#0593A2">非抢占式调度: </font>**
  挑选一个进程, 直到其**<font color="#0593A2">被阻塞或者运行结束</font>**才会去调用另一个进程, 也就是不会去处理时钟中断
- **<font color="#0593A2">抢占式调度: </font>**
  挑选一个进程, 然后让该进程只运行一段时间, 如果该进程在该时段结束时仍在运行, 则会把该进程挂起, 接着再从就绪链表中挑选另一个进程. 这种方式通过时间末端触发中断来进行调度, 称为**<font color="#0593A2">时间片机制</font>**

Linux 中进程/线程任务具有优先级之分, 为了让高优先级的任务被尽早执行, 分出了以下三种调度类: 

|  调度类  |     调度器      |         调度策略         | 运行队列 |
|:--------|:---------------:|:------------------------:|:--------:|
| Deadline | Deadline 调度器 |     `SCHED_DEADLINE`     |  dl_rq   |
| Realtime |    RT 调度器    | `SCHED_FIFO`, `SCHED_RR` |  rt_rq   |
|Fair|CFS 调度器| `SCHED_NORMAL`, `SCHED_BATCH` |cfs_rq|

- Deadline 和 Realtime 调度类用于<font color="#0593A2">实时任务 (优先级 0~99)</font>
    - `SCHED_DEADLINE`: 按照距离当前时间点最近的 deadline 的任务进行优先调度
    - `SCHED_FIFO`: 对于优先级相同的任务采取先来先服务, 但是优先级高的任务可以抢占优先级低的任务
    - `SCHED_RR`: 对于优先级相同的任务采取时间片的方式轮流运行, 用完当前时间片的任务会被放到任务队尾, 但是高优先级任务可以抢占低优先级任务
- Fair 类用于<font color="#0593A2">普通任务 (优先级 100~139)</font>, 都是由[[完全公平调度|CFS]]调度器进行管理
    - `SCHED_NORMAL`: 用于普通任务调度
    - `SCHED_BATCH`: 后台任务调度策略, 在不影响其他需要交互的任务的前提下, 可以适当降低它的优先级

**调度原则**
1. **<font color="#0593A2">CPU 利用率: </font>**如果运行的程序，发生了 I/O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，为了提高 CPU 利用率，在这种发送 I/O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行
2. **<font color="#0593A2">系统吞吐量: </font>**有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）的降低。所以，要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量
3. **<font color="#0593A2">周转时间: </font>**从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生
4. **<font color="#0593A2">等待时间: </font>**处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU 中执行。所以，就绪队列中进程的等待时间也是调度程序所需要考虑的原则
5. **<font color="#0593A2">响应时间: </font>**对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则

**调度算法**
- 先来先服务 (*First Come First Serve*, FCFS)
- 

---
#### Source
- [2.5 CPU 是如何执行任务的？ | 小林coding](https://xiaolincoding.com/os/1_hardware/how_cpu_deal_task.html#%E5%88%86%E6%9E%90%E4%BC%AA%E5%85%B1%E4%BA%AB%E7%9A%84%E9%97%AE%E9%A2%98)
# 概述
- 实现了一个 N-M 的协程调度器，N 个线程运行 M 个协程，协程可以在线程之间进行切换，也可以绑定到指定线程运行
- 实现协程调度之后，可以解决前一章协程模块中子协程不能运行另一个子协程的缺陷，子协程可以通过向调度器添加调度任务的方式来运行另一个子协程
- 引入协程调度后，则可以先创建一个协程调度器，然后把这些要调度的协程传递给调度器，由调度器负责把这些协程一个一个消耗掉

- 首先是关于调度任务的定义，对于协程调度器来说，协程当然可以作为调度任务，但实际上，函数也应可以，因为函数也是可执行的对象，调度器应当支持直接调度一个函数。这在代码实现上也很简单，只需要将函数包装成协程即可，协程调度器的实现重点还是以协程为基础
- 一个线程同一时刻只能运行一个协程，所以，作为协程调度器，势必要用到多线程来提高调度的效率，因为有多个线程就意味着有多个协程可以同时执行
- 调度器创建后，内部首先会创建一个调度线程池，调度开始后，所有调度线程按顺序从任务队列里取任务执行，调度线程数越多，能够同时调度的任务也就越多，当所有任务都调度完后，调度线程就停下来等新的任务进来
- 调度器应该支持停止调度的功能，以便回收调度线程的资源，只有当所有的调度线程都结束后，调度器才算真正停止

# 模块设计
- 协程调度模块支持多线程，支持使用 caller 线程进行调度，支持添加函数或协程作为调度对象，并且支持将函数或协程绑定到一个具体的线程上执行
- 程调度器在初始化时支持传入线程数和一个布尔型的 use_caller 参数，表示是否使用 caller 线程。在使用 caller 线程的情况下，线程数自动减一，并且调度器内部会初始化一个属于 caller 线程的调度协程并保存起来（比如，在 main 函数中创建的调度器，如果 use_caller 为 true，那调度器会初始化一个属于 main 函数线程的调度协程
- 调度器创建好后，即可调用调度器的 schedule 方法向调度器添加调度任务，但此时调度器并不会立刻执行这些任务，而是将它们保存到内部的一个任务队列中
- 接下来是调度协程，对应 run 方法。调度协程负责从调度器的任务队列中取任务执行。取出的任务即子协程，这里调度协程和子协程的切换模型即为非对称模型，每个子协程执行完后都必须返回调度协程，由调度协程重新从任务队列中取新的协程并执行。如果任务队列空了，那么调度协程会切换到一个 idle 协程，这个 idle 协程什么也不做，等有新任务进来时，idle 协程才会退出并回到调度协程，重新开始下一轮调度
- 接下来是添加调度任务，对应 schedule 方法，这个方法支持传入协程或函数，并且支持一个线程号参数，表示是否将这个协程或函数绑定到一个具体的线程上执行。如果任务队列为空，那么在添加任务之后，要调用一次 tickle 方法以通知各调度线程的调度协程有新任务来了
- 在执行调度任务时，还可以通过调度器的 GetThis ()方法获取到当前调度器，再通过 schedule 方法继续添加新的任务，这就变相实现了在子协程中创建并运行新的子协程的功能
- 
